/*
         * Export kMaxLength after typed array support is determined.
         */

/*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */

/*
        _metadata = _metadata.filter((elm)=> !(
        	elm.name === "Seek" ||
        	elm.name === "SeekID" ||
        	elm.name === "SeekPosition") );
        */

/*
       * Need to make sure that buffer isn't trying to write out of bounds.
       */

/* Desired Metadata
      	 m	0 EBML
       u	1   EBMLVersion 1
       u	1   EBMLReadVersion 1
       u	1   EBMLMaxIDLength 4
       u	1   EBMLMaxSizeLength 8
       s	1   DocType webm
       u	1   DocTypeVersion 4
       u	1   DocTypeReadVersion 2
       m	0 Segment
       m	1   SeekHead                            -> This is SeekPosition 0, so all SeekPositions can be calculated as (bytePos - segmentContentStartPos), which is 44 in this case
       m	2     Seek
       b	3       SeekID                          -> Buffer([0x15, 0x49, 0xA9, 0x66])  Info
       u	3       SeekPosition                    -> infoStartPos =
       m	2     Seek
       b	3       SeekID                          -> Buffer([0x16, 0x54, 0xAE, 0x6B])  Tracks
       u	3       SeekPosition { tracksStartPos }
       m	2     Seek
       b	3       SeekID                          -> Buffer([0x1C, 0x53, 0xBB, 0x6B])  Cues
       u	3       SeekPosition { cuesStartPos }
       m	1   Info
       f	2     Duration 32480                    -> overwrite, or insert if it doesn't exist
       u	2     TimecodeScale 1000000
       8	2     MuxingApp Chrome
       8	2     WritingApp Chrome
       m	1   Tracks
       m	2     TrackEntry
       u	3       TrackNumber 1
       u	3       TrackUID 31790271978391090
       u	3       TrackType 2
       s	3       CodecID A_OPUS
       b	3       CodecPrivate <Buffer 19>
       m	3       Audio
       f	4         SamplingFrequency 48000
       u	4         Channels 1
       m	2     TrackEntry
       u	3       TrackNumber 2
       u	3       TrackUID 24051277436254136
       u	3       TrackType 1
       s	3       CodecID V_VP8
       m	3       Video
       u	4         PixelWidth 1024
       u	4         PixelHeight 576
       m  1   Cues                                -> cuesStartPos
       m  2     CuePoint
       u  3       CueTime 0
       m  3       CueTrackPositions
       u  4         CueTrack 1
       u  4         CueClusterPosition 3911
       m  2     CuePoint
       u  3       CueTime 600
       m  3       CueTrackPositions
       u  4         CueTrack 1
       u  4         CueClusterPosition 3911
       m  1   Cluster
       u  2     Timecode 0
       b  2     SimpleBlock track:2 timecode:0	keyframe:true	invisible:false	discardable:false	lacing:1
      */

/* Original Metadata
      	 m  0	EBML
       u  1	  EBMLVersion 1
       u  1	  EBMLReadVersion 1
       u  1	  EBMLMaxIDLength 4
       u  1	  EBMLMaxSizeLength 8
       s  1	  DocType webm
       u  1	  DocTypeVersion 4
       u  1	  DocTypeReadVersion 2
       m  0	Segment
       m  1	  Info                                segmentContentStartPos, all CueClusterPositions provided in info.cues will be relative to here and will need adjusted
       u  2	    TimecodeScale 1000000
       8  2	    MuxingApp Chrome
       8  2	    WritingApp Chrome
       m  1	  Tracks                              tracksStartPos
       m  2	    TrackEntry
       u  3	      TrackNumber 1
       u  3	      TrackUID 31790271978391090
       u  3	      TrackType 2
       s  3	      CodecID A_OPUS
       b  3	      CodecPrivate <Buffer 19>
       m  3	      Audio
       f  4	        SamplingFrequency 48000
       u  4	        Channels 1
       m  2	    TrackEntry
       u  3	      TrackNumber 2
       u  3	      TrackUID 24051277436254136
       u  3	      TrackType 1
       s  3	      CodecID V_VP8
       m  3	      Video
       u  4	        PixelWidth 1024
       u  4	        PixelHeight 576
       m  1	  Cluster                             clusterStartPos
       u  2	    Timecode 0
       b  2	    SimpleBlock track:2 timecode:0	keyframe:true	invisible:false	discardable:false	lacing:1
      */

/* WEBPACK VAR INJECTION */

/* eslint-disable */

/* eslint-disable jsx-a11y/media-has-caption */

/* harmony default export */

/* harmony import */

/*#__PURE__*/

/**
      	* @param end - if end === false then length is unknown
      	*/

/**
           * DefaultDuration が定義されている場合は最後のフレームのdurationも考慮する
           * 単位 timecodeScale
           *
           * !!! if you need duration with seconds !!!
           * ```js
           * const nanosec = reader.duration * reader.timecodeScale;
           * const sec = nanosec / 1000 / 1000 / 1000;
           * ```
           */

/**
           * 親要素が閉じタグあり(isEnd)なら閉じタグが来るまで待つ(children queに入る)
           */

/**
           * 閉じタグ不定長の場合はスタックに積まずに即時バッファに書き込む
           */

/**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/

/**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */

/**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */

/**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/

/**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Due to various browser bugs, sometimes the Object implementation will be used even
         * when the browser supports typed arrays.
         *
         * Note:
         *
         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *     incorrect length in some situations.
        	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
         * get the Object implementation, which is slower but behaves correctly.
         */

/**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

/**
         * emit chunk info
         */

/**
         * emit final state.
         */

/**
         * vint された parsing tag
         * @return - return false when waiting for more data
         */

/**
         * vint された現在のタグの内容の大きさを読み込む
         * @return - return false when waiting for more data
         */

/**
         * データ読み込み
         */

/**
       * @deprecated
       * metadata に対して duration と seekhead を追加した metadata を返す
       * @param metadata - 変更前の webm における ファイル先頭から 最初の Cluster 要素までの 要素
       * @param duration - Duration (TimecodeScale)
       * @param cues - cue points for clusters
       * @deprecated @param clusterPtrs - 変更前の webm における SeekHead に追加する Cluster 要素 への start pointer
       * @deprecated @param cueInfos - please use cues.
       */

/**
       * @param frame - VP8 BitStream のうち startcode をもつ frame
       * @return - WebP ファイルの ArrayBuffer
       */

/**
       * @return - SimpleBlock to WebP Filter
       */

/**
       * Creates a new filled Buffer instance.
       * alloc(size[, fill[, encoding]])
       **/

/**
       * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
       * */

/**
       * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
       */

/**
       * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
       * if value is a number.
       * Buffer.from(str[, encoding])
       * Buffer.from(array)
       * Buffer.from(buffer)
       * Buffer.from(arrayBuffer[, byteOffset[, length]])
       **/

/**
       * If `Buffer.TYPED_ARRAY_SUPPORT`:
       *   === true    Use Uint8Array implementation (fastest)
       *   === false   Print warning and recommend using `buffer` v4.x which has an Object
       *               implementation (most compatible, even IE6)
       *
       * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
       * Opera 11.6+, iOS 4.2+.
       *
       * We report that the browser does not support typed arrays if the are not subclassable
       * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
       * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
       * for __proto__ and has a buggy typed array implementation.
       */

/**
       * RIFF データチャンクを作る
       */

/**
       * The Buffer constructor returns instances of `Uint8Array` that have their
       * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
       * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
       * and the `Uint8Array` methods. Square bracket notation works as expected -- it
       * returns a single octet.
       *
       * The `Uint8Array` prototype remains unmodified.
       */

/**
       * WebP ファイルにできる SimpleBlock の パスフィルタ
       */

/**
       * convert the metadata from a streaming webm bytestream to a seekable file by inserting Duration, Seekhead and Cues
       * @param originalMetadata - orginal metadata (everything before the clusters start) from media recorder
       * @param duration - Duration (TimecodeScale)
       * @param cues - cue points for clusters
       */

/**
       * extract the first occurance of an EBML tag from a flattened array of EBML data.
       * If it's a MasterElement you will also get the content. (everything between start and end)
       * @param idName - name of the EBML Element to extract.
       * @param metadata - array of EBML elements to search
       */

/**
       * print all element id names in a list
      	 * @param metadata - array of EBML elements to print
       *
      export function printElementIds(metadata: EBML.EBMLElementBuffer[]) {
      		let result: EBML.EBMLElementBuffer[] = [];
      	let start: number = -1;
      		for (let i = 0; i < metadata.length; i++) {
      		console.error("\t id: " + metadata[i].name);
      	}
      }
      */

/**
       * remove all occurances of an EBML element from an array of elements
       * If it's a MasterElement you will also remove the content. (everything between start and end)
       * @param idName - name of the EBML Element to remove.
       * @param metadata - array of EBML elements to search
       */

/**
* An ISLE component for recording audio, screen and video.
*
* @property {boolean} audio - indicates whether audio should be recorded
* @property {boolean} camera - indicates whether webcam should be recorded
* @property {boolean} screen - indicates whether the screen should be captured
* @property {boolean} autostart - indicates whether recording should start immediately
* @property {boolean} downloadable - indicates whether users should be able to download the recording
* @property {boolean} uploadable - indicates whether users should be able to upload the recording to the server
* @property {number} bitsPerSecond - bits per second
* @property {string} voiceID - voice control identifier
* @property {Object} style - CSS inline styles
*/

/** @class */

/***/

//

//                           ^                                                 |

//                           inf

//                           |                                                 *??=newPayloadOffsetEnd

//                 [Segment][size][Info][size][Duration][size]....[size][value][Cluster]

//                 |        |     +-newPayloadSize(??)-------------------------+

//                 |        |     |                                            |

//    buffer.fill(buffer[, offset[, end]])

//    buffer.fill(number[, offset[, end]])

//    buffer.fill(string[, offset[, end]][, encoding])

//  Printable ASCII (0x20 to 0x7E), zero-padded when needed

//  Unicode string, zero padded when needed (RFC 2279)

// "Software"), to deal in the Software without restriction, including

// "br": "",

// "br": [ "", "" ],

// "br": [ "", "", "" ],

// "br": [ "", "", "", "" ],

// "del": [ "1 - bzlib,", "2 - lzo1x" ],

// 'abxxcd' will be treated as 'ab')

// *0    *4    *5  *36      *40   *48=segmentOffset              *185=originalPayloadOffsetEnd

// +-ebmlSize(36)--+        |     +-payloadSize(137)-------------+offsetEndDiff+

// - buffer - a Buffer to search

// - byteOffset - an index into `buffer`; will be clamped to an int32

// - dir - true for indexOf, false for lastIndexOf

// - encoding - an optional encoding, relevant is val is a string

// - val - a string, Buffer, or number

// 1 => video

// 2 => audio

// 2 leads in a row

// 64bit

// <<<<<<<<

// = first cluster ptr

// ================

// >>>>>>>>>

// Adding the second element, need to change to array.

// Are we oob?

// Arguments:

// Array

// Array;

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass

// At least give some kind of context to the user

// Backwards-compat with node 0.10.x

// Based on http://stackoverflow.com/a/22747272/680742, the browser with

// Big-endian, any size from 1 to 8

// Big-endian, any size from 1 to 8 octets

// Big-endian, defined for 4 and 8 octets (32, 64 bits)

// Binary - not interpreted by the parser

// Buffer instances.

// Buffer#write(string)

// By default EventEmitters will print a warning if more than 10 listeners are

// Can typed array instances can be augmented?

// Case: Audio

// Case: Camera + Audio / No Audio

// Case: Screen & Audio

// Case: Screen & Camera

// Case: Screen without Audio

// Check for listener leak

// Coerce to Number.

// Common case.

// CommonJS

// Copy 0 bytes; we're done

// Copyright Joyent, Inc. and other Node contributors.

// Cues

// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR

// Date - signed 8 octets integer in nanoseconds with 0 indicating

// Decode in chunks to avoid "call stack size exceeded".

// EBML variable sized integers

// EBMLReader returns CueClusterPosition with absolute byte offsets. The Cues section expects them as offsets from the first level 1 element of the Segment, so we need to adjust it.

// EXPORTS //

// Empty buffer means no match

// Exports

// FUNCTIONS //

// Fallback to WebAudio solution:

// Fallback: Return an object instance of the Buffer class

// Fast path: If `val` fits into a single byte, use that numeric value.

// Fatal error conditions

// Finally, search either indexOf (if dir is true) or lastIndexOf

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97

// Float - Big-endian, defined for 4 and 8 octets (32, 64 bits)

// For IE11 support

// Force coersion to uint32. This will also coerce falsey/NaN values to 0.

// From http://w3c.github.io/media-source/webm-byte-stream-format.html#webm-media-segments

// Given a list of EBMLElementBuffers, returns their encoded size in bytes

// HELPER FUNCTIONS

// Handle string cases:

// If the new MetadataSize is not the same as the previous iteration, we need to run once more.

// If there is no 'error' event listener then throw.

// If we've already got an array, just append.

// Info

// Info comes directly after SeekHead

// Int64BE() style

// Int64BE(buffer, offset) style

// Int64BE(buffer, offset, value, raddix) style

// Int64BE(value, raddix) style

// Invalid ranges are not set to a default, so can range check early.

// LIFO order

// MAIN //

// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN

// MODULES //

// Master-Element - contains other EBML sub-elements of the next lower level

// Module

// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,

// NaN

// No need to verify that "this.length <= MAX_UINT32" since it's a read-only

// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

// Node converts strings with length < 2 to ''

// Node strips out invalid characters like \n and \t from the string, base64-js does not

// Node takes equal signs as end of the Base64 encoding

// Node's code seems to be doing this and not & 0x7F..

// Normalize byteOffset

// Normalize byteOffset: negative offsets start from the end of the buffer

// Normalize val

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:

// Note: cannot use `length < K_MAX_LENGTH` here because that fails when

// Note: cannot use `length < kMaxLength()` here because that fails when

// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

// OR the last index of `val` in `buffer` at offset <= `byteOffset`.

// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE

// Obviously not all Emitters should be limited to 10. This function allows

// Optimize the case of one listener. Don't need the extra array object.

// PROPERTIES //

// Permission is hereby granted, free of charge, to any person obtaining a

// Return an augmented `Uint8Array` instance

// Return an augmented `Uint8Array` instance, for best performance

// Return early if start > this.length. Done here to prevent potential uint32

// Search for a byte value [0-255]

// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

// See: https://en.wikipedia.org/wiki/Base64#URL_applications

// See: https://github.com/beatgammit/base64-js/issues/42

// See: https://github.com/feross/buffer/issues/154

// See: https://github.com/feross/buffer/issues/166

// SeekHead starts at 0

// Signed Integer - Big-endian, any size from 1 to 8 octets

// Size is stable

// Special case: looking for empty string/buffer always fails

// Support decoding URL-safe base64 strings, as Node.js does.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS

// TODO: Legacy, not needed anymore. Remove in next major version.

// The above copyright notice and this permission notice shall be included

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect

// This behaves neither like String nor Uint8Array in that we set start/end

// This fixes logging for webm streams with Cluster of unknown length and no Cluster closing elements.

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)

// To avoid recursion in the case that type === "newListener"! Before

// Tracks

// Trim off extra bytes after placeholder bytes are found

// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Unhandled 'error' event

// Unsigned Integer - Big-endian, any size from 1 to 8 octets

// Usage:

// Use a for loop to avoid recursion

// Use built-in when available, missing from IE11

// VARIABLES //

// VP8 の場合

// Warning: maxLength not taken into account in base64Write

// We also need to adjust to take into account the change in metadata size from when EBMLReader read the original metadata.

// We go 1 magnitude less, for safety

// Writing a hex string, for example, that contains invalid characters will

// [0x1F, 0x43, 0xB6, 0x75] で Cluster 意

// [EBML][size]....[Segment][size][Info][size][Duration][size]...[Cluster]

// a super limited subset of the node buffer API

// a trick to get signed

// add .toArrayBuffer() method only when Uint8Array available

// add .toBuffer() method only when Buffer available

// added to it. This is a useful default which helps finding memory leaks.

// adding it to the listeners, first emit "newListener".

// alter Buffer.concat - https://github.com/feross/buffer/issues/154

// ascending copy from start

// ascii

// assume utf8

// audio diff

// audio timecode

// avoid extra slice()

// base64 is 4/3 + up to two characters of the original data

// buffer slice

// but js number is float64, so max 6 bit

// but js number is float64, so max 6 bit octets

// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer

// cause everything after the first invalid character to be ignored. (e.g.

// chrome 58 ではこれを回避するために DefaultDuration 要素を抜き取った。

// chrome 58 以前でもこのタグを抜き取ることで回避できる

// chrome 9-10 lack `subarray`

// class factory

// clean up any unclosed Master Elements at the end of the stream.

// close main group if set, logging is enabled, and has actually logged anything.

// coercion fail below.

// console.error(`cuesStart: ${cuesStart}, cuesSize: ${cuesSize}`);

// console.error(`infoStart: ${infoStart}, infoSize: ${infoSize}`);

// console.error(`originalMetadataSize: ${originalMetadataSize}, newMetadataSize: ${newMetadataSize}, sizeDifference: ${sizeDifference}`);

// console.error(`tracksStart: ${tracksStart}, tracksSize: ${tracksSize}`);

// console.log('content should be tags');

// constants

// constructor

// convert to timecodescale

// copies of the 'buffer' package in use. This method works even for Buffer

// copy of this software and associated documentation files (the

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)

// create the Cues element

// create the SeekHead element

// current tag の data size 決定

// default duration がないときに使う delta

// defaultDuration は 生の nano sec

// descending copy from end

// distribute, sublicense, and/or sell copies of the Software, and to permit

// duration を追加する

// else { not reached }

// emit removeListener for all listeners on all events

// emits a 'removeListener' event iff the listener was removed

// encode to utf16 (surrogate pair dance)

// encode utf8

// eslint-disable-line eqeqeq

// eslint-disable-line no-self-compare

// extract the header, we can reuse this as-is

// extract the track info, we can re-use this as is

// fast cases

// find first audio track

// find first video track

// find the tagname from _metadata

// first frame

// following conditions:

// for debug

// generate classes

// go through the array every three bytes, we'll deal with trailing stuff later

// high

// https://bugs.chromium.org/p/chromium/issues/detail?id=606000#c22

// https://developers.Blob.com/speed/webp/docs/riff_container

// https://github.com/feross/buffer/pull/148

// https://github.com/retrofox/is-array

// https://github.com/themasch/node-ebml/blob/master/lib/ebml/tools.js

// ie10 has broken `subarray`

// if it's a Master element, extract the start and end element, and everything in between

// in all copies or substantial portions of the Software.

// initializer

// insert <Cues />

// insert [<CuePoint />] to <Cues />

// instances that were created from another copy of the `buffer` package.

// is surrogate component

// isUint64BE, isInt64BE

// js number is float64 so 8 bytes.

// last char was a lead

// last frame (remaining buffer)

// length is NaN (which is otherwise coerced to zero.)

// master element は子要素を持つので生データはない

// media source api は DefaultDuration を計算するとバグる。

// metadata 末尾に <Cues /> を追加

// methods

// middle frames

// monitor, window, application, browser

// must be an even number of digits

// must be multiple of 3

// nano second; Date.UTC(2001,1,1,0,0,0,0) === 980985600000

// nanoseconds

// no lead yet

// not a Master element, so we've found what we're looking for.

// not listening for removeListener, no need to emit

// not supported in IE 10

// not used by this implementation

// number of frames

// only valid for SimpleBlock

// pad the end with zeros, but make sure to not forget the extra bytes

// persons to whom the Software is furnished to do so, subject to the

// properties

// property of a typed array.

// read ebml datasize vint without first byte

// read ebml id vint without first byte

// reliably in a browserify context because there could be multiple different

// remaining bytes to read

// remaining data should be divisible by the number of frames

// remove seek info

// remove segment tag

// remove the object from the stack

// replacement char (U+FFFD) and advance only 1 byte

// shortcut to initialize with zero

// slower

// so Buffer.isBuffer(Buffer.prototype) will be false

// tag が読めなかった

// tag 識別子

// tag.length が buffer の外にある

// that to be increased. Set to zero for unlimited.

// the `instanceof` check but they should be treated as of that type.

// the lowest limit is Chrome, with 0x10000 args.

// the precise beginning of the millennium (at 2001-01-01T00:00:00,000000000 UTC)

// this throws if `array` is not a valid ArrayBuffer

// to detect a Buffer instance. It's not possible to use `instanceof Buffer`

// to their upper/lower bounds if the value passed is out of range.

// trackType === 1 => video track

// trackType === 2 => audio track

// typed array instances can be augmented

// undefined is handled specially as per ECMA-262 6th Edition,

// unexpected trail

// unknown size

// unpaired lead

// valid lead

// valid surrogate pair

// video diff

// video timecode

// video track

// waiting for more data

// we did not generate a valid codePoint so insert a

// we've reached the end, extract the whole thing

// webm default TimecodeScale is 1ms

// without limitation the rights to use, copy, modify, merge, publish,

// working on progress

// |               +segmentSiz(12)+                              |

// |               |        |^inf |                              |

// |     |     |   |        |     |                              |

// | tag: vint | size: vint | data: Buffer(size) |

// この Mastert Element は空要素か

// まだ読めない

// タグの中身の生データ

// タグ待ちモードに変更

// ポインタを進める

// 一旦 seekhead を作って自身のサイズを調べる

// 上と等価

// 即座に終了タグを追加

// 親が不定長サイズなので閉じタグは期待できない

// 親タグを捨てる

// 読みかけの(読めなかった) this._buffer と 新しい chunk を合わせて読み直す

// 読み終わったバッファを捨てて読み込んでいる部分のバッファのみ残す

// 読み込み状態変更

// 閉じタグなしでレベルが下がったら閉じタグを挿入

// 閉じタグの来るべき場所まで来たかどうか

// 閉じタグの自動挿入

// 閉じタグを挿入すべきタイミングが来た

/// <reference types="node"/>

//case "m": break;

//console.error("Cue count: " + cuesInfo.length);

//console.error("Cues size: " + cuesSize);

//console.error("Info size: " + infoSize);

//console.error("SeekHead size: " + seekHeadSize);

//console.error(`CueClusterPosition: ${CueClusterPosition}, Corrected to: ${CueClusterPosition - segmentContentStartPos}  , offset by ${sizeDifference} to become ${(CueClusterPosition - segmentContentStartPos) + sizeDifference - segmentContentStartPos}`);

//console.error(`Final metadata buffer size without header and segment: ${result.byteLength-segmentContentStartPos}`);

//console.error(`Final metadata buffer size: ${result.byteLength}`);

//console.log(elm.name, elm.type, o.trackNumber, o.timecode);

//const o = EBML.tools.ebmlBlock(elm.value);

//const tagNum = parseInt(tagStr, 16);

//const tagStr = this._buffer.toString("hex", this._cursor, this._cursor + tag.length);

//if(elm.name === "SimpleBlock"){

//printElementIds(cues);

//printElementIds(finalMetadata);

//printElementIds(info);

//printElementIds(seekHead);

//return Buffer.concat.apply(Buffer, list);

//seekhead_children = seekhead_children.concat(create_seekhead(_metadata));

//}else{
