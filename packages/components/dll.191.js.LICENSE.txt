/* */

/* eslint-disable no-return-assign */

/* harmony default export */

/* harmony export (binding) */

/* harmony import */

/* harmony reexport (safe) */

/*#__PURE__*/

/**
         * If a prop switches from controlled to Uncontrolled
         * reset its value to the defaultValue
         */

/**
   * A Callback fired by the Overlay when it wishes to be hidden.
   *
   * __required__ when `rootClose` is `true`.
   *
   * @type func
   */

/**
   * A DOM Element, Ref to an element, or function that returns either. The `container` will have the Portal children
   * appended to it.
   */

/**
   * A DOM Element, Ref to an element, or function that returns either. The `target` element is where
   * the overlay is positioned relative to.
   */

/**
   * A `react-transition-group@2.0.0` `<Transition/>` component
   * used to animate the overlay as it changes visibility.
   */

/**
   * A render prop that returns an element to overlay and position. See
   * the [react-popper documentation](https://github.com/FezVrasta/react-popper#children) for more info.
   *
   * @type {Function ({
   *   show: boolean,
   *   placement: Placement,
   *   update: () => void,
   *   forceUpdate: () => void,
   *   props: {
   *     ref: (?HTMLElement) => void,
   *     style: { [string]: string | number },
   *     aria-labelledby: ?string
   *     [string]: string | number,
   *   },
   *   arrowProps: {
   *     ref: (?HTMLElement) => void,
   *     style: { [string]: string | number },
   *     [string]: string | number,
   *   },
   * }) => React.Element}
   */

/**
   * A set of popper options and props passed directly to react-popper's Popper component.
   */

/**
   * Callback fired after the Overlay finishes transitioning in
   */

/**
   * Callback fired after the Overlay finishes transitioning out
   */

/**
   * Callback fired as the Overlay begins to transition in
   */

/**
   * Callback fired as the Overlay begins to transition out
   */

/**
   * Callback fired before the Overlay transitions in
   */

/**
   * Callback fired right before the Overlay transitions out
   */

/**
   * Control how much space there is between the edge of the boundary element and overlay.
   * A convenience shortcut to setting `popperConfig.modfiers.preventOverflow.padding`
   */

/**
   * Enables the Popper.js `flip` modifier, allowing the Overlay to
   * automatically adjust it's placement in case of overlap with the viewport or toggle.
   * Refer to the [flip docs](https://popper.js.org/popper-documentation.html#modifiers..flip.enabled) for more info
   */

/**
   * If a prop switches from controlled to Uncontrolled
   * reset its value to the defaultValue
   */

/**
   * Set the visibility of the Overlay
   */

/**
   * Specify disabled for disable RootCloseWrapper
   */

/**
   * Specify event for toggling overlay
   */

/**
   * Specify whether the overlay should trigger `onHide` when the user clicks outside the overlay
   */

/**
   * useful when wrapping a Component and you want to control
   * everything
   */

/**
 * An `addEventListener` ponyfill, supports the `once` option
 */

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 * https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/vendor/core/hyphenateStyleName.js
 */

/**
 * Creates a `Ref` whose value is updated in an effect, ensuring the most recent
 * value is the one rendered with. Generally only required for Concurrent mode usage
 * where previous work in `render()` may be discarded befor being used.
 *
 * This is safe to access in an event handler.
 *
 * @param value The `Ref` value
 */

/**
 * Returns a controller object for setting a timeout that is properly cleaned up
 * once the component unmounts. New timeouts cancel and replace existing ones.
 */

/**
 * Store the last of some value. Tracked via a `Ref` only updating it
 * after the component renders.
 *
 * Helpful if you need to compare a prop value to it's previous value during render.
 *
 * ```ts
 * function Component(props) {
 *   const lastProps = usePrevious(props)
 *
 *   if (lastProps.foo !== props.foo)
 *     resetValueFromProps(props.foo)
 * }
 * ```
 *
 * @param value the value to track
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

/** Specify where the overlay element is positioned in relation to the target element */

/***/

//         nextStatus = ENTERING

//         nextStatus = EXITING

//       if (status !== ENTERING && status !== ENTERED) {

//       if (status === ENTERING || status === ENTERED) {

//       }

//     const { status } = this.state

//     if (this.props.in) {

//     }

//     } else {

//   if (prevProps !== this.props) {

//   let nextStatus = null

//   return { nextStatus }

//   }

// "consumed" by the delegate iterator. If context.method was

// "return" to "throw", let that override the TypeError below.

// "return", allow the original .return call to continue in the

// .constructor.prototype properties for functions that return Generator

// .throw, and .return (see defineIteratorMethods).

// .throw, and .return methods.

// 16.3+ will not execute our will-update method;

// @@iterator function is called on it. Some browsers' implementations of the

// @ts-ignore

// A .throw or .return when the delegate iterator has no .throw

// A Generator should always return itself as the iterator object when the

// Add a flag to suppress these warnings for this special case.

// As a workaround, use cWM and cWRP to invoke the new static lifecycle.

// As a workaround, use cWU to invoke the new lifecycle.

// Assign the result of the finished delegate to the temporary

// AsyncIterator objects; they just return a Promise for the value of

// Avoid propagating failures to Promises returned by later

// Be forgiving, per 25.3.3.3.3 of the spec:

// Because for <= 15.x versions this might be a "prevContext" object.

// Because get-snapshot might return a falsy value.

// Because they would work differently between older and newer (16.3+) versions of React.

// Binding "this" is important for shallow renderer support.

// CSP to forbid Function, and you're not willing to fix either of those

// Call delegate.iterator[context.method](context.arg) and handle the

// Call this.constructor.gDSFP to support sub-classes.

// Define Generator.prototype.{next,throw,return} in terms of the

// Define the unified helper method that is used to implement .next,

// Deliberately forget the last sent value so that we don't

// Dispatch the exception by looping back around to the

// Don't bother showing anything if we don't have to.

// Don't un-render the overlay while it's transitioning out.

// Dummy constructor functions that we use as the .constructor and

// Error if any of these lifecycles are present,

// Exception thrown outside of any try block that could handle

// For simplicity, if the timeout is short, just set a normal timeout.

// For the native GeneratorFunction constructor, the best we can

// GenStateExecuting and loop back for another invocation.

// Helper for defining the .next, .throw, and .return methods of the

// IE 8 has a broken Object.defineProperty that only works on DOM objects.

// If a rejected Promise was yielded, throw the rejection back

// If an exception is thrown from innerFn, we leave state ===

// If context.method was "throw" but the delegate handled the

// If enqueue has been called before, then we want to wait until

// If maybeInvokeDelegate(context) changed context.method from

// If new component APIs are defined, "unsafe" lifecycles won't be called.

// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.

// If the delegate iterator has a return method, give it a

// If the dispatched exception was caught by a catch block,

// Ignore the finally entry if control is not jumping to a

// In the context of a TransitionGroup all enters are really appears

// It will pass a snapshot value to did-update though.

// Iterator interface in terms of a single ._invoke method.

// Name the function so it is clearer in the documentation

// Newer versions of React will ignore that lifecycle if gSBU exists.

// Newer versions of React will ignore these lifecycles if gDSFP exists.

// Not sure about the optimal order of these conditions:

// Note that simple async functions are implemented on top of

// Note: ["return"] must be used for ES3 parsing compatibility.

// Older versions will require our polyfilled will-update value.

// Rather than returning an object with a next method, we keep

// React <= 16.2 does not support getSnapshotBeforeUpdate.

// React <= 16.2 does not support static getDerivedStateFromProps.

// React may warn about cWM/cWRP/cWU methods being deprecated.

// React's built version is broken: https://github.com/facebook/react/issues/4251

// Regardless of whether this script is executing as a CommonJS module

// Resetting context._sent for legacy support of Babel's

// Resume execution at the desired location (see delegateYield).

// Return an iterator with no values.

// See https://github.com/facebook/regenerator/issues/274 for more details.

// Setting context._sent for legacy support of Babel's

// Simple implementation of mouseEnter and mouseLeave.

// So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.

// TODO: remove fallback for next major

// The ._invoke method unifies the implementations of the .next,

// The context.catch method must only be called with a location

// The delegate iterator is finished, so forget it and continue with

// The root entry object (effectively a try statement without a catch

// This environment has a native %IteratorPrototype%; use it instead

// This is a polyfill for %IteratorPrototype% for environments that

// This module should not be running in strict mode, so the above

// This shouldn't be necessary, but there are weird race conditions with

// To avoid creating an additional object, we just hang the .value

// Try/catch helper to minimize deoptimizations. Returns a completion

// Use the setState() updater to ensure state isn't stale in certain edge cases.

// We also can't just check "__reactInternalSnapshot",

// We need to handle both cases, but can't just check for the presence of "maybeSnapshot",

// When a yielded Promise is resolved, its final value becomes

// Within the body of any async function, `await x` is transformed to

// `hasOwn.call(value, "__await")` to determine if the yielded value is

// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test

// accidentally pass it on to the delegate.

// add default propTypes for folks that use runtime checks

// all previous Promises have been resolved before calling invoke,

// allows for nested Transitions

// already have an existing method we want to call, so there's no need

// also ensures that the minifier will not anonymize the function.

// and .done properties off the next function object itself. This

// any necessary setup in a predictable way. This predictability

// argument that corresponds to a known catch block.

// assignment should always work unless something is misconfigured. Just

// async functions in terms of async generators, it is especially

// call invoke immediately, without waiting on a callback to fire,

// chance to clean up.

// context.dispatchException(context.arg) call above.

// context.method was "next", forget context.arg since it has been

// current iteration.

// delegate iterator, or by modifying context.method and context.arg,

// do is to check its .name property.

// don't natively support it.

// enqueue has not been called before, then it is important to

// eslint-disable-next-line @typescript-eslint/no-unused-expressions

// eslint-disable-next-line no-multi-assign

// exception, let the outer generator proceed normally. If

// execute code before the first await. Since we implement simple

// executor callback, and why async functions synchronously

// for cases when the trigger is disabled and mouseOut/Over can cause flicker

// function.sent implementation.

// getSnapshotBeforeUpdate(prevProps) {

// has a stable shape and so hopefully should be cheap to allocate.

// have been (and was previously) designed to take a closure to be

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume

// if a Content Security Policy forbids using Function, but in that case

// if we are mounting and running this it means appear _must_ be set

// important to get this right, even though it requires care.

// in case runtime.js accidentally runs in strict mode, we can escape

// in every case, so we don't have to touch the arguments object. The

// injected easily by `bin/regenerator --include-runtime script.js`.

// into the async generator function so it can be handled there.

// invocations of the iterator.

// invoked without arguments, but in all the cases we care about we

// is why the Promise constructor synchronously invokes its

// it, so set the completion value of the entire function to

// iterator prototype chain incorrectly implement this, causing the Generator

// location outside the try/catch block.

// locations where there is no enclosing try statement.

// meant to be awaited.

// method always terminates the yield* loop.

// minifier not to mangle the names of these two functions.

// moving from one child element to another.

// nextStatus will always be ENTERING or EXITING.

// no enter animation skip right to ENTERED

// no exit animation skip right to EXITED

// object to not be returned from this call. This ensures that doesn't happen.

// objects. For full spec compliance, you may wish to configure your

// of the polyfill.

// only additional allocation required is the completion record, which

// or a finally block) gives us a place to store values thrown from

// or not, return the runtime object so that we can declare the variable

// outer generator.

// problems, please detail your unique predicament in a GitHub issue.

// reading a dimension prop will cause the browser to recalculate,

// record like context.tryEntries[i].completion. This interface could

// regeneratorRuntime in the outer scope, which allows this module to be

// result, either by returning a { value, done } result from the

// setState callbacks and unmounting in testing, so always make sure that

// setting context.delegate to null, and returning the ContinueSentinel.

// so that results are always delivered in the correct order. If

// so that the async generator function has the opportunity to do

// strict mode using a global Function call. This could conceivably fail

// the .value of the Promise<{value,done}> result for the

// the final result produced by the iterator.

// the method takes exactly one argument, since that happens to be true

// the outer generator.

// the proper solution is to fix the accidental strict mode problem. If

// then let that catch block handle the exception normally.

// things simple and return the next function itself.

// throw the exception.

// to create a new function object. We can even get away with assuming

// types are confused between node and web here IDK

// unified ._invoke helper method.

// variable specified by delegate.resultName (see delegateYield).

// we can cancel any pending setState callbacks after we unmount.

// we don't care about invariant's own frame

// which will let our animations work

// you've misconfigured your bundler to force strict mode and applied a

// }

//let setState trigger the update
