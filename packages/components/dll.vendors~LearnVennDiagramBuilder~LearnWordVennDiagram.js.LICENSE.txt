/* From FvD 13.37, CSS Color Module Level 3 */

/* harmony default export */

/* harmony export (binding) */

/* harmony import */

/* harmony reexport (safe) */

/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */

/** Gets all intersection points between a bunch of circles */

/** Given a bunch of sets, and the desired overlaps between these sets - computes
the distance from the actual overlaps to the desired overlaps. Note that
this method ignores overlaps of more than 2 circles */

/** Given two circles (containing a x/y/radius attributes),
returns the intersecting points if possible.
note: doesn't handle cases where there are infinitely many
intersection points (circles are equivalent):, or only one intersection point*/

/** Lays out a Venn diagram greedily, going from most overlapped sets to
least overlapped, attempting to position each new set such that the
overlapping areas to already positioned sets are basically right */

/** Missing pair-wise intersection area data can cause problems:
 treating as an unknown means that sets will be laid out overlapping,
 which isn't what people expect. To reflect that we want disjoint sets
 here, set the overlap to 0 for all missing pairwise set intersections */

/** Returns the center of a bunch of points */

/** Returns the distance necessary for two circles of radius r1 + r2 to
have the overlap area 'overlap' */

/** Returns the intersection area of a bunch of circles (where each circle
 is an object having an x,y and radius property) */

/** Returns the overlap area of two circles of radius r1 and r2 - that
have their centers separated by distance d. Simpler faster
circle intersection for only two circles */

/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in
a rectangle of width/height - with padding around the borders. also
centers the diagram in the available space at the same time */

/** euclidean distance between two points */

/** finds the zeros of a function, given two starting points (which must
 * have opposite signs */

/** given a list of set objects, and their corresponding overlaps.
updates the (x, y, radius) attribute on each set such that their positions
roughly correspond to the desired overlaps */

/** minimizes a function using the downhill simplex method */

/** returns a svg path of the intersection area of a bunch of circles */

/** returns whether a point is contained by all of a list of circles */

/***/

/*global console:true*/

// (sometimes slightly overflows because of FP errors)

// Add any remaining nodes that were not bound to data to exit.

// Add remains of b.

// Assuming this is successful, subsequent callbacks go straight to tick.

// Coerce inputs to strings.

// Compute the key for each datum.

// Compute the key for each node.

// Defer the first tick to end of the current frame; see d3/d3#1576.

// Deprecated! Use color.formatHex.

// Dispatch the end event.

// Dispatch the start event.

// Events can be reentrant (e.g., focus).

// Figure out the current label for each set. These can change

// For context during callback.

// Get the current time, if not already set.

// I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10

// If a type was specified, set the callback for the given type and name.

// If multiple nodes have the same key, the duplicates are added to exit.

// If no callback was specified, return the callback of the given type and name.

// If the elapsed delay is less than our first sleep, start immediately.

// If the state is not SCHEDULED, then we previously errored on start.

// If there a node associated with this key, join and add it to update.

// If there is not (or the key is a duplicate), add it to enter.

// If this node shared a dispatch with the previous node,

// If this node shared tween with the previous node,

// Initialize the self timer when the transition is created.

// Initialize the tween, deleting null tween.

// Interpolate pairs of numbers in a & b.

// Interrupt the active transition, if any.

// Note the actual delay is not known until the first callback!

// Note the transition may be canceled after start and before the first tick!

// Note this must be done before the tween are initialized.

// Note this must be scheduled before the start event; see d3/d3-transition#16!

// Now connect the enter nodes to their following update node, such that

// Otherwise, copy-on-write.

// Otherwise, if a null callback was specified, remove callbacks of the given name.

// Otherwise, interpolate each of the numbers and rejoin the string.

// Pretend we’ve set an alarm, if we haven’t already.

// Protect against keys like “__proto__”.

// Put any non-null nodes that don’t fit into exit.

// Put any non-null nodes that fit into update.

// Put any null nodes into enter.

// Put any remaining data into enter.

// Set on use.

// Soonest alarm already set, or will be.

// Special optimization for only a single match.

// Strictly less than if we recomputed clockNow.

// TODO: proper preconditioner?

// While this element already has a starting transition during this frame,

// a dictionary of setid to list of circles that completely overlap it

// a particular area is on top (relativeTo) - and

// a string precedes the next number in b

// add in missing pairwise areas as having 0 size

// add most overlapped set at (0,0)

// adds a point to the output

// all other areas are so that the smallest areas are on top

// allocate all memory up front here, keep out of the loop for perfomance

// also update constraints to indicate if its a subset or disjoint

// also worth checking out is

// and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)

// and don't consider for purposes of computing the text

// and taking the point with the biggest margin

// and update the areas

// and use that angle to figure out the width of the

// answer: probably not

// appendChild can insert the materialized enter node before this node,

// apply minimal style if wanted

// arc

// at each position to figure out where to put it at

// bidirectionally map sets to a rowid  (so we can create a matrix)

// but d3 3.0 used 'each' instead. switch appropiately

// centre

// chance to tick (and possibly end); see d3/d3-transition#54!

// checks that all sets are in exclude;

// clamp the width to the largest is can actually be

// cleanup bookkeeping

// completely overlapped

// completely overlapped circles shouldn't be positioned early here

// compute required distances between all the sets such that

// compute the center of some circles by maximizing the margin of

// compute the centroid of all but the worst point in the simplex

// constrained MDS for higher order problems, take its output

// convert back to solution form

// copy the simplex (since later iterations will mutate) and

// create svg if not already existing

// current match in a

// current match in b

// current paths

// d3 4.0 uses 'on' for events on transitions,

// defer starting an interrupting transition until that transition has a

// define a circle for each set

// do a reduction

// do an inside contraction

// do an outside contraction

// don't mutate input

// draw path around arcs

// ems

// eslint-disable-line no-unused-vars

// faiiled to find point that satifies wolfe conditions.

// figure out sets that are completly overlapped by relativeTo

// figure out the angle halfway between the two points

// filter out points that aren't included in all the circles

// find all the disjoint clusters and group them together

// first two circles

// from largest

// gc

// get all the disjoint clusters

// get all the intersection points of the circles

// get an initial estimate by sampling around the interior circles

// get appropriate distance from most overlapped already added set

// get distances between all points. TODO, necessary?

// get list of most overlapped sets

// get the union of all overlapping sets

// given a dictionary of {setid : circle}, returns

// greedylayout is sufficient for all 2/3 circle cases. try out

// handle 0-sized sets by removing from input

// handle complete overlapped circles

// have one cluster (in top left). lay out next three relative

// highest order set intersections first

// how frequently we check for clock skew

// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/

// https://github.com/mbostock/d3/issues/1642),

// if it outperforms. (greedy is aesthetically better on 2/3 circles

// if the reflected point is the best seen, then possibly expand

// if to far away, or self contained - can't be done

// if we don't contract here, we're done

// if we have at least 2 overlaps, then figure out where the

// if we have intersection points that are within all the circles,

// if we've been passed a fontSize explicitly, use it to

// index in s

// initialize an empty distance matrix between all the points

// initialize simplex.

// interpolate intersection area paths between previous and

// interpolate non-matching numbers

// interrupted

// inverse of the circlePath function, returns a circle object from an svg path

// is a timeout pending?

// is an animation frame pending?

// iterate over all points, get arc between the points

// just assign the updated shared dispatch and we’re done!

// just assign the updated shared tween and we’re done!

// just define here

// keep distances bounded, things get messed up otherwise.

// keep track of any circles that overlap this area,

// keep track of what sets have been laid out

// make sure the smallest circle is completely contained in all

// map each set to a list of all the other sets that overlap it

// maximize the margin numerically

// mimic the behaviour of d3.scale.category10 from the previous

// mirror solution if third solution is above plane specified by

// nearby circles (exterior)

// need some basic operations on vectors, rather than adding a dependency,

// need to sort div's so that Z order is correct

// no intersection points, is either disjoint - or is completely

// no overlap

// node is a Document

// number interpolators

// numbers in a & b match

// on the current circle

// optimize initial layout from our loss function

// orientate all disjoint sets, get sizes

// orientate the largest at 0,0, and get the bounds

// orientates a bunch of circles to point in orientation

// overlapped. figure out which by examining the smallest circle

// path compression step in union find

// pick the circle whose arc has the smallest width

// point

// polygon area updates easily ...

// previous circles locations. load from elements

// rather than at the end of the parent node.

// reasons

// reflect the worst point past the centroid  and compute loss at reflected

// relationship

// remove old

// reset direction for next iteration

// return in more usable form

// rotate circles so that second largest is at an angle of 'orientation'

// sample positions at 90 degrees for maximum aesthetics

// scan index for next number in b

// set should be positioned analytically and try those too

// shift circles so largest circle is at (0, 0)

// shortest path

// since it axis aligns)

// since we can support older versions of d3 as long as we don't force this,

// so this is the same as d3.schemeCategory10, which is only defined in d3 4.0

// sometimes text doesn't fit inside the circle, if thats the case lets wrap

// sort by size desc

// sort it to have a consistent order between iterations

// sort the points by angle from the center of the polygon, which lets

// sorts all areas in the venn diagram, so that

// string constants and placeholders

// string preceding current number in b, if any

// the areas match

// the center point relative to the circles (interior) after subtracting

// the other circles

// the text here such that it fits

// then figure out the area contained by them

// this seems to be one of those things that should be easy but isn't

// this shouldn't happen anymore with addMissingAreas

// to it in a grid

// to properly transition intersection areas, we need the

// todo: history in wrong spot?

// todo: looks like this might be merged into d3 (

// transform solution vector back to x/y points

// transition

// translate rows back to (x,y,radius) coordinates

// two circle intersections that aren't defined

// union-find clustering to get disjoint sets

// update data, joining on the set ids

// update direction using Polak–Ribiere CG method

// update existing, using pathTween if necessary

// updating the arc area is a little more involved

// us just iterate over points to get the edges

// var distances = venn.getDistanceMatrices(circles, areas).distances;

// version of d3

// we have some candidate positions for the set, examine loss

// while we're at it, center the diagram too

// work with a list instead of a dictionary, and take a copy so we

/// Returns two matrices, one of the euclidean distances between the sets

/// See 'Numerical Optimization' by Nocedal and Wright p59-60

/// and the other indicating if there are subset or disjoint set relationships

/// computes the gradient and loss simulatenously for our constrained MDS optimizer

/// current: object containing current gradient/loss

/// f : objective function

/// next: output: contains next gradient/loss

/// pk : search direction

/// returns a: step size taken

/// searches along line 'pk' for a point that satifies the wolfe conditions

/// takes the best working variant of either constrained MDS or greedy

/// use the constrained MDS variant to generate an initial layout
