/*
	* Create the index input arguments along with the value to set...
	* > function set( i0, i1, ..., v ) {
	*/

/*
	* Create the index input arguments...
	* > function get( i0, i1, ...) {
	*/

/*
	* Create the index input arguments...
	* > function set( i0, i1,..., v ) {
	*/

/*
	* Index into the array according to the offset and strides...
	* > data[offset+strides[0]*i0+strides[1]*i1+...] = v;
	*/

/*
	* Index into the array according to the offset and strides...
	* > return data[offset+strides[0]*i0+strides[1]*i1+...];
	*/

/*
	* Resolve indices based on the index mode.
	* > i0 = getIndex( i0, shape[0]-1, mode );
	*/

/*
	* Type check each index.
	* > if ( !isInteger( i0 ) ) { throw new TypeError( ... ) }
	*/

/*
	* e.g.,
	*
	*   function flattenArray( x ) {
	*       var o = [];
	*       var i0, i1;
	*       for ( i0 = 0; i0 < 2; i0++ ) {
	*           for ( i1 = 0; i1 < 2; i1++ ) {
	*               o.push( x[i0][i1] );
	*           }
	*       }
	*       return o;
	*   }
	*/

/*
	* e.g.,
	*     function get( i0, i1, i2 ) {
	*         if ( !isInteger( i0 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 0. Value: `'+i0+'`.' );
	*         }
	*         if ( !isInteger( i1 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 1. Value: `'+i1+'`.' );
	*         }
	*         if ( !isInteger( i2 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 2. Value: `'+i2+'`.' );
	*         }
	*         i0 = getIndex( i0, this._shape[0]-1, 'throw' );
	*         i1 = getIndex( i1, this._shape[1]-1, 'throw' );
	*         i2 = getIndex( i2, this._shape[2]-1, 'throw' );
	*         return this._buffer[ this._offset + this._strides[0]*i0 + this._strides[1]*i1 + this._strides[2]*i2 ];
	*     }
	*/

/*
	* e.g.,
	*     function get( i0, i1, i2 ) {
	*         return this._buffer[ this._offset + this._strides[0]*i0 + this._strides[1]*i1 + this._strides[2]*i2 ];
	*     }
	*/

/*
	* e.g.,
	*     function set( i0, i1, i2, v ) {
	*         if ( !isInteger( i0 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 0. Value: `'+i0+'`.' );
	*         }
	*         if ( !isInteger( i1 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 1. Value: `'+i1+'`.' );
	*         }
	*         if ( !isInteger( i2 ) ) {
	*             throw new TypeError( 'invalid argument. Indices must be integer valued. Argument: 2. Value: `'+i2+'`.' );
	*         }
	*         i0 = getIndex( i0, this._shape[0]-1, 'throw' );
	*         i1 = getIndex( i1, this._shape[1]-1, 'throw' );
	*         i2 = getIndex( i2, this._shape[2]-1, 'throw' );
	*         this._buffer[ this._offset + this._strides[0]*i0 + this._strides[1]*i1 + this._strides[2]*i2 ] = v;
	*         return this;
	*     }
	*/

/*
	* e.g.,
	*     function set( i0, i1, i2, v ) {
	*         this._buffer[ this._offset + this._strides[0]*i0 + this._strides[1]*i1 + this._strides[2]*i2 ] = v;
	*         return this;
	*     }
	*/

/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

/* 0 */

/* 1 */

/* 10 */

/* 11 */

/* 12 */

/* 13 */

/* 14 */

/* 15 */

/* 2 */

/* 3 */

/* 4 */

/* 5 */

/* 6 */

/* 7 */

/* 8 */

/* 9 */

/* WEBPACK VAR INJECTION */

/* eslint-disable no-bitwise, no-cond-assign */

/* eslint-disable no-invalid-this */

/* eslint-disable no-restricted-syntax */

/* eslint-disable no-unused-vars */

/* eslint-enable no-invalid-this */

/* global Symbol */

/* harmony default export */

/* harmony export (binding) */

/* harmony import */

/*#__PURE__*/

/**
		 * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.
		 * @return Array of "chunks" (where a Chunk is { start:number, end:number, highlight:boolean })
		 */

/**
		 * Given a set of chunks to highlight, create an additional set of chunks
		 * to represent the bits of text between the highlighted text.
		 * @param chunksToHighlight {start:number, end:number}[]
		 * @param totalLength number
		 * @return {start:number, end:number, highlight:boolean}[]
		 */

/**
		 * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.
		 * @return {start:number, end:number}[]
		 */

/**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

/**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */

/**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */

/**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */

/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */

/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

/**
	 * Highlights all occurrences of search terms (searchText) within a string (textToHighlight).
	 * This function returns an array of strings and <span>s (wrapping highlighted words).
	 */

/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */

/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

/**
	* Array order.
	*
	* ## Notes
	*
	* -   The array order is either row-major (C-style) or column-major (Fortran-style).
	*
	*
	* @private
	* @name order
	* @memberof ndarray.prototype
	* @type {string}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var order = x.order;
	* // returns 'row-major'
	*/

/**
	* Flattens an array and deep copies array elements.
	*
	* @private
	* @param {Array} arr - array to flatten
	* @throws {TypeError} must provide an array
	* @returns {Array} flattened array
	*/

/**
	* Flattens an array.
	*
	* @private
	* @param {Array} arr - array to flatten
	* @throws {TypeError} must provide an array
	* @returns {Array} flattened array
	*/

/**
	* Index offset which specifies the buffer index at which to start iterating over array elements.
	*
	* @private
	* @name offset
	* @memberof ndarray.prototype
	* @type {NonNegativeInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var o = x.offset;
	* // returns 0
	*/

/**
	* Index strides which specify how to access data along corresponding array dimensions.
	*
	* @private
	* @name strides
	* @memberof ndarray.prototype
	* @type {IntegerArray}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var s = x.strides;
	* // returns [ 2, 1 ]
	*/

/**
	* Information about the memory layout of the array.
	*
	* @private
	* @name flags
	* @memberof ndarray.prototype
	* @type {Object}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var flgs = x.flags;
	* // returns <Object>
	*/

/**
	* Length of the array.
	*
	* @private
	* @name length
	* @memberof ndarray.prototype
	* @type {NonNegativeInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var len = x.length;
	* // returns 6
	*/

/**
	* Number of dimensions.
	*
	* @private
	* @name ndims
	* @memberof ndarray
	* @type {PositiveInteger}
	*
	* @example
	* var ndims = ndarray.ndims;
	* // returns <number>
	*/

/**
	* Number of dimensions.
	*
	* @private
	* @name ndims
	* @memberof ndarray.prototype
	* @type {PositiveInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var ndims = x.ndims;
	* // returns <number>
	*/

/**
	* Pointer to the underlying data buffer.
	*
	* @private
	* @name data
	* @memberof ndarray.prototype
	* @type {(Array|TypedArray|Buffer)}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var data = x.data;
	* // returns [ 1, 2, 3, 4, 5, 6 ]
	*/

/**
	* Returns an array element located at a specified linear index.
	*
	* @private
	* @name iget
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {integer} idx - linear index
	* @returns {*} array element
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.iget( 3 );
	* // returns 4
	*/

/**
	* Returns an array element located at a specified linear index.
	*
	* @private
	* @param {integer} idx - linear view index
	* @throws {TypeError} index must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @name get
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {...integer} idx - indices
	* @returns {*} array element
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.get( 1, 1 );
	* // returns 4
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {...integer} idx - indices
	* @throws {TypeError} provided indices must be integer valued
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {integer} i - index
	* @throws {TypeError} index must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {integer} k - index for third dimension
	* @param {integer} l - index for fourth dimension
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {TypeError} index for third dimension must be an integer value
	* @throws {TypeError} index for fourth dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {integer} k - index for third dimension
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {TypeError} index for third dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Returns an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {*} array element
	*/

/**
	* Serializes an ndarray as a JSON object.
	*
	* ## Notes
	*
	* -   `JSON.stringify()` implicitly calls this method when stringifying an `ndarray` instance.
	* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
	*
	*
	* @private
	* @name toJSON
	* @memberof ndarray.prototype
	* @type {Function}
	* @returns {Object} serialized ndarray
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 2;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var o = x.toJSON();
	* // e.g., returns { 'type': 'ndarray', 'dtype': '<dtype>', 'flags': {...}, 'offset': 0, 'order': 'row-major', 'shape': [ 3, 2 ], 'strides': [ 2, 1 ], 'data': [ 3, 4, 5, 6, 7, 8 ] }
	*/

/**
	* Serializes an ndarray as a string.
	*
	* ## Notes
	*
	* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
	*
	*
	* @private
	* @name toString
	* @memberof ndarray.prototype
	* @type {Function}
	* @returns {string} serialized ndarray
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 2;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var str = x.toString();
	* // e.g., returns 'ndarray( [ 3, 4, 5, 6, 7, 8 ], [ 3, 2 ], [ 2, 1 ], 0, "row-major" )'
	*/

/**
	* Sets an array element located at a specified linear index.
	*
	* @private
	* @name iset
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {integer} idx - linear index
	* @param {*} v - value to set
	* @returns {ndarray} ndarray instance
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.iget( 3 );
	* // returns 4
	*
	* x.iset( 3, 10 );
	*
	* var b = x.data;
	* // returns [ 1, 2, 3, 10, 5, 6 ]
	*
	* v = x.iget( 3 );
	* // returns 10
	*/

/**
	* Sets an array element located at a specified linear index.
	*
	* @private
	* @param {integer} idx - linear view index
	* @param {*} v - value to set
	* @throws {TypeError} index must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @name set
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {...integer} idx - indices
	* @param {*} v - value to set
	* @returns {ndarray} ndarray instance
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.get( 1, 1 );
	* // returns 4
	*
	* x.set( 1, 1, 10 );
	*
	* var b = x.data;
	* // returns [ 1, 2, 3, 10, 5, 6 ]
	*
	* v = x.get( 1, 1 );
	* // returns 10
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {...integer} idx - indices
	* @param {*} v - value to set
	* @throws {TypeError} provided indices must be integer valued
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {integer} i - index
	* @param {*} v - value to set
	* @throws {TypeError} index must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {*} v - value to set
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {integer} k - index for third dimension
	* @param {*} v - value to set
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {TypeError} index for third dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Sets an array element.
	*
	* @private
	* @param {integer} i - index for first dimension
	* @param {integer} j - index for second dimension
	* @param {integer} k - index for third dimension
	* @param {integer} l - index for fourth dimension
	* @param {*} v - value to set
	* @throws {TypeError} index for first dimension must be an integer value
	* @throws {TypeError} index for second dimension must be an integer value
	* @throws {TypeError} index for third dimension must be an integer value
	* @throws {TypeError} index for fourth dimension must be an integer value
	* @throws {RangeError} index exceeds array dimensions
	* @returns {ndarray} ndarray instance
	*/

/**
	* Shape of the array.
	*
	* @private
	* @name shape
	* @memberof ndarray.prototype
	* @type {NonNegativeIntegerArray}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var s = x.shape;
	* // returns [ 3, 2 ]
	*/

/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @name BYTES_PER_ELEMENT
	* @memberof ndarray
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var nbytes = ndarray.BYTES_PER_ELEMENT;
	* // returns <number>
	*/

/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @name BYTES_PER_ELEMENT
	* @memberof ndarray.prototype
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var Float64Array = require( '@stdlib/array/float64' );
	*
	* var buffer = new Float64Array( [ 1, 2, 3, 4, 5, 6 ] );
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var nbytes = x.BYTES_PER_ELEMENT;
	* // returns 8
	*/

/**
	* Size (in bytes) of the array (if known).
	*
	* @private
	* @name byteLength
	* @memberof ndarray.prototype
	* @type {(NonNegativeInteger|null)}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var byteLength = x.byteLength;
	* // returns <number>
	*/

/**
	* Tests if every element in an array-like object passes a test condition.
	*
	* @private
	* @param {*} value - value to test
	* @returns {boolean} boolean indicating whether a value is an array-like object for which all elements pass a test condition
	*/

/**
	* Underlying data type.
	*
	* @private
	* @name dtype
	* @memberof ndarray
	* @type {string}
	*
	* @example
	* var dtype = ndarray.dtype;
	* // returns <string>
	*/

/**
	* Underlying data type.
	*
	* @private
	* @name dtype
	* @memberof ndarray.prototype
	* @type {string}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var dtype = x.dtype;
	* // returns <string>
	*/

/**
	* ndarray constructor.
	*
	* @private
	* @constructor
	* @param {(ArrayLikeObject|TypedArray|Buffer)} buffer - data buffer
	* @param {NonNegativeIntegerArray} shape - array shape
	* @param {IntegerArray} strides - array strides
	* @param {NonNegativeInteger} offset - index offset
	* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
	* @returns {ndarray} ndarray instance
	*/

/**
	* ndarray constructor.
	*
	* @private
	* @constructor
	* @param {(ArrayLikeObject|TypedArray|Buffer)} buffer - data buffer
	* @param {NonNegativeIntegerArray} shape - array shape
	* @param {IntegerArray} strides - array strides
	* @param {NonNegativeInteger} offset - index offset
	* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
	* @throws {TypeError} `buffer` argument must be an array-like object, typed-array-like, or a Buffer
	* @throws {TypeError} `shape` argument must be an array-like object containing nonnegative integers
	* @throws {Error} `shape` argument length must equal the number of dimensions
	* @throws {TypeError} `strides` argument must be an array-like object containing integers
	* @throws {Error} `strides` argument length must equal the number of dimensions
	* @throws {TypeError} `offset` argument must be a nonnegative integer
	* @throws {TypeError} `order` argument must be a supported ndarray order
	* @throws {Error} `buffer` argument must be compatible with specified meta data
	* @returns {ndarray} ndarray instance
	*/

/**
 * A convenience hook around `useState` designed to be paired with
 * the component [callback ref](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs) api.
 * Callback refs are useful over `useRef()` when you need to respond to the ref being set
 * instead of lazily accessing it in an effect.
 *
 * ```ts
 * const [element, attachRef] = useCallbackRef<HTMLDivElement>()
 *
 * useEffect(() => {
 *   if (!element) return
 *
 *   const calendar = new FullCalendar.Calendar(element)
 *
 *   return () => {
 *     calendar.destroy()
 *   }
 * }, [element])
 *
 * return <div ref={attachRef} />
 * ```
 *
 * @category refs
 */

/**
 * Iterates through children that are "valid elements".
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child with the index reflecting the position relative to "valid components".
 */

/**
 * Iterates through children that are typically specified as `props.children`,
 * but only maps over children that are "valid elements".
 *
 * The mapFunction provided index will be normalised to the components mapped,
 * so an invalid component would not increase the index.
 *
 */

/**
 * Store the last of some value. Tracked via a `Ref` only updating it
 * after the component renders.
 *
 * Helpful if you need to compare a prop value to it's previous value during render.
 *
 * ```ts
 * function Component(props) {
 *   const lastProps = usePrevious(props)
 *
 *   if (lastProps.foo !== props.foo)
 *     resetValueFromProps(props.foo)
 * }
 * ```
 *
 * @param value the value to track
 */

/**
 * This file automatically generated from `pre-publish.js`.
 * Do not manually edit.
 */

/**
 * Track whether a component is current mounted. Generally less preferable than
 * properlly canceling effects so they don't run after a component is unmounted,
 * but helpful in cases where that isn't feasible, such as a `Promise` resolution.
 *
 * @returns a function that returns the current isMounted state of the component
 *
 * ```ts
 * const [data, setData] = useState(null)
 * const isMounted = useMounted()
 *
 * useEffect(() => {
 *   fetchdata().then((newData) => {
 *      if (isMounted()) {
 *        setData(newData);
 *      }
 *   })
 * })
 * ```
 */

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* Allocate a buffer having a specified number of bytes.
*
* @module @stdlib/buffer/alloc-unsafe
*
* @example
* var allocUnsafe = require( '@stdlib/buffer/alloc-unsafe' );
*
* var buf = allocUnsafe( 10 );
* // returns <Buffer>
*/

/**
* Allocates a buffer having a specified number of bytes.
*
* ## Notes
*
* -   The underlying memory of returned `Buffer` instances is not initialized. Memory contents are unknown and may contain sensitive data.
* -   When the size is less than half the pool size (specified on the `Buffer` constructor), memory is allocated from the `Buffer` pool for faster allocation of new `Buffer` instances.
*
*
* @param {NonNegativeInteger} size - number of bytes to allocate
* @throws {TypeError} must provide a nonnegative integer
* @returns {Buffer} new `Buffer` instance
*
* @example
* var buf = allocUnsafe( 10 );
* // returns <Buffer>
*/

/**
* An `Object.create` shim for older JavaScript engines.
*
* @private
* @param {Object} proto - prototype
* @returns {Object} created object
*
* @example
* var obj = createObject( Object.prototype );
* // returns {}
*/

/**
* Attempts to call a `RegExp` method.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating if able to call a `RegExp` method
*/

/**
* Casts buffer elements by copying those elements to a buffer of another data type.
*
* @private
* @param {(Array|TypedArray|Buffer)} buffer - input buffer
* @param {NonNegativeInteger} len - number of elements to cast
* @param {string} dtype - data type
* @returns {(Array|TypedArray|Buffer)} output buffer
*
* @example
* var b = castBuffer( [ 1.0, 2.0, 3.0 ], 3, 'float64' );
* // returns <Float64Array>[ 1.0, 2.0, 3.0 ]
*/

/**
* Compute the absolute difference.
*
* @module @stdlib/math/base/utils/absolute-difference
*
* @example
* var diff = require( '@stdlib/math/base/utils/absolute-difference' );
*
* var d = diff( 2.0, 5.0 );
* // returns 3.0
*
* d = diff( -1.0, 3.14 );
* // returns ~4.14
*
* d = diff( 10.1, -2.05 );
* // returns ~12.15
*
* d = diff( -0.0, 0.0 );
* // returns +0.0
*
* d = diff( NaN, 5.0 );
* // returns NaN
*
* d = diff( Infinity, -Infinity  );
* // returns Infinity
*
* d = diff( Infinity, Infinity  );
* // returns NaN
*/

/**
* Compute the minimum and maximum linear indices in an underlying data buffer which are accessible to an array view.
*
* @module @stdlib/ndarray/base/minmax-view-buffer-index
*
* @example
* var minmaxViewBufferIndex = require( '@stdlib/ndarray/base/minmax-view-buffer-index' );
*
* var shape = [ 10, 10 ];
* var strides = [ 10, 1 ];
* var offset = 10;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 10, 109 ]
*
* @example
* var minmaxViewBufferIndex = require( '@stdlib/ndarray/base/minmax-view-buffer-index' );
*
* var shape = [ 10, 10 ];
* var strides = [ -10, -1 ];
* var offset = 99;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 0, 99 ]
*
* @example
* var minmaxViewBufferIndex = require( '@stdlib/ndarray/base/minmax-view-buffer-index' );
*
* var shape = [ 10, 10 ];
* var strides = [ 1, 10 ];
* var offset = 10;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 10, 109 ]
*
* @example
* var minmaxViewBufferIndex = require( '@stdlib/ndarray/base/minmax-view-buffer-index' );
*
* var shape = [ 10, 10 ];
* var strides = [ -1, -10 ];
* var offset = 99;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 0, 99 ]
*/

/**
* Computes the absolute difference.
*
* @param {number} x - first number
* @param {number} y - second number
* @returns {number} absolute difference
*
* @example
* var d = absoluteDifference( 2.0, 5.0 );
* // returns 3.0
*
* @example
* var d = absoluteDifference( -1.0, 3.14 );
* // returns ~4.14
*
* @example
* var d = absoluteDifference( 10.1, -2.05 );
* // returns ~12.15
*
* @example
* var d = absoluteDifference( -0.0, 0.0 );
* // returns +0.0
*
* @example
* var d = absoluteDifference( NaN, 5.0 );
* // returns NaN
*
* @example
* var d = absoluteDifference( Infinity, -Infinity  );
* // returns Infinity
*
* @example
* var d = absoluteDifference( Infinity, Infinity  );
* // returns NaN
*/

/**
* Computes the minimum and maximum linear indices in an underlying data buffer which are accessible to an array view.
*
* @param {(Array|TypedArray|Object)} [out] - output object
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @param {NonNegativeInteger} offset - index offset
* @returns {(Array|TypedArray|Object)} linear indices
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ 10, 1 ];
* var offset = 10;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 10, 109 ]
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -10, -1 ];
* var offset = 99;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 0, 99 ]
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ 1, 10 ];
* var offset = 10;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 10, 109 ]
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -1, -10 ];
* var offset = 99;
*
* var idx = minmaxViewBufferIndex( shape, strides, offset );
* // returns [ 0, 99 ]
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -1, -10 ];
* var offset = 99;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 0, 99 ]
*
* var bool = ( idx === out );
* // returns true
*/

/**
* Computes the minimum and maximum linear indices in an underlying data buffer which are accessible to an array view.
*
* @private
* @param {(Array|TypedArray|Object)} out - output object
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @param {NonNegativeInteger} offset - index offset
* @returns {(Array|TypedArray|Object)} linear indices
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ 10, 1 ];
* var offset = 10;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 10, 109 ]
*
* var bool = ( idx === out );
* // returns true
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -10, -1 ];
* var offset = 99;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 0, 99 ]
*
* var bool = ( idx === out );
* // returns true
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ 1, 10 ];
* var offset = 10;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 10, 109 ]
*
* var bool = ( idx === out );
* // returns true
*
* @example
* var shape = [ 10, 10 ];
* var strides = [ -1, -10 ];
* var offset = 99;
*
* var out = new Array( 2 );
* var idx = minmaxViewBufferIndex( out, shape, strides, offset );
* // returns [ 0, 99 ]
*
* var bool = ( idx === out );
* // returns true
*/

/**
* Convert a string to lowercase.
*
* @module @stdlib/string/lowercase
*
* @example
* var lowercase = require( '@stdlib/string/lowercase' );
*
* var str = lowercase( 'bEEp' );
* // returns 'beep'
*/

/**
* Converts a string to lowercase.
*
* @param {string} str - string to convert
* @throws {TypeError} must provide a primitive string
* @returns {string} lowercase string
*
* @example
* var str = lowercase( 'bEEp' );
* // returns 'beep'
*/

/**
* Copies an ndarray view to a data buffer.
*
* @private
* @param {ndarray} arr - input ndarray
* @param {string} dtype - data type
* @returns {(Array|TypedArray|Buffer)} output data buffer
*
* @example
* var ndarray = require( '@stdlib/ndarray/ctor' );
*
* var vector = ndarray( 'generic', 1 );
*
* var buffer = [ 1.0, 2.0, 3.0 ];
* var shape = [ 3 ];
* var strides = [ -1 ];
* var vec = vector( buffer, shape, strides, 2, 'row-major' );
*
* var b = copyView( vec, 'float64' );
* // returns <Float64Array>[ 3.0, 2.0, 1.0 ]
*/

/**
* Copies ndarray flags.
*
* @private
* @param {Object} flags - flags
* @returns {Object} copy of input object
*/

/**
* Copies the contents of array-like object to a new array.
*
*
* @private
* @param {ArrayLike} arr - input array
* @param {NonNegativeInteger} len - array length
* @returns {Array} output array
*
* @example
* var arr = [ 1.0, 2.0, 3.0 ];
*
* var out = copy( arr, arr.length );
* // returns [ 1.0, 2.0, 3.0 ]
*
* var bool = ( arr === out );
* // returns false
*/

/**
* Create a memoized ndarray constructor.
*
* @module @stdlib/ndarray/base/memoized-ctor
*
* @example
* var ctor = require( '@stdlib/ndarray/base/memoized-ctor' );
*
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Create a memoized ndarray constructor.
*
* @module @stdlib/ndarray/memoized-ctor
*
* @example
* var ctor = require( '@stdlib/ndarray/memoized-ctor' );
*
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Create a zero-filled contiguous linear ndarray data buffer.
*
* @module @stdlib/ndarray/base/buffer
*
* @example
* var buffer = require( '@stdlib/ndarray/base/buffer' );
*
* var buf = buffer( 'float64', 3 );
* // returns <Float64Array>[ 0.0, 0.0, 0.0 ]
*/

/**
* Create an ndarray constructor.
*
* @module @stdlib/ndarray/base/ctor
*
* @example
* var ctor = require( '@stdlib/ndarray/base/ctor' );
*
* var ndarray = ctor( 'float64', 3 );
* // returns <Function>
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Create an ndarray constructor.
*
* @module @stdlib/ndarray/ctor
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
*
* var ndarray = ctor( 'generic', 3 );
* // returns <Function>
*
* var buffer = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Define a read-only property.
*
* @module @stdlib/utils/define-read-only-property
*
* @example
* var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
*
* var obj = {};
*
* setReadOnly( obj, 'foo', 'bar' );
*
* try {
*     obj.foo = 'boop';
* } catch ( err ) {
*     console.error( err.message );
* }
*/

/**
* Defines a read-only property.
*
* @param {Object} obj - object on which to define the property
* @param {(string|symbol)} prop - property name
* @param {*} value - value to set
*
* @example
* var obj = {};
*
* setReadOnly( obj, 'foo', 'bar' );
*
* try {
*     obj.foo = 'boop';
* } catch ( err ) {
*     console.error( err.message );
* }
*/

/**
* Determine (nested) array dimensions.
*
* @module @stdlib/array/shape
*
* @example
* var arrayShape = require( '@stdlib/array/shape' );
*
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];
*
* var shape = arrayShape( arr );
* // returns [ 3, 3 ]
*
* @example
* var arrayShape = require( '@stdlib/array/shape' );
*
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8 ] ];
*
* var shape = arrayShape( arr );
* // returns [ 3 ]
*
* @example
* var arrayShape = require( '@stdlib/array/shape' );
*
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], null ];
*
* var shape = arrayShape( arr );
* // returns [ 3 ]
*/

/**
* Determine if an array data type can be cast to another array data type according to a specified casting rule.
*
* @module @stdlib/ndarray/base/assert/is-allowed-data-type-cast
*
* @example
* var isAllowedCast = require( '@stdlib/ndarray/base/assert/is-allowed-data-type-cast' );
*
* var bool = isAllowedCast( 'float32', 'float64', 'safe' );
* // returns true
*
* bool = isAllowedCast( 'float64', 'int32', 'safe' );
* // returns false
*/

/**
* Determine if an ndarray data type can be safely cast to another ndarray data type.
*
* @module @stdlib/ndarray/base/assert/is-safe-data-type-cast
*
* @example
* var isSafeCast = require( '@stdlib/ndarray/base/assert/is-safe-data-type-cast' );
*
* var bool = isSafeCast( 'float32', 'float64' );
* // returns true
*
* bool = isSafeCast( 'float64', 'int32' );
* // returns false
*/

/**
* Determine if an ndarray data type can be safely cast to, or is of the same "kind" as, another ndarray data type.
*
* @module @stdlib/ndarray/base/assert/is-same-kind-data-type-cast
*
* @example
* var isSameKindCast = require( '@stdlib/ndarray/base/assert/is-same-kind-data-type-cast' );
*
* var bool = isSameKindCast( 'float32', 'float64' );
* // returns true
*
* bool = isSameKindCast( 'uint16', 'int16' );
* // returns false
*/

/**
* Determine the index offset which specifies the location of the first indexed value in a multidimensional array based on a stride array.
*
* @module @stdlib/ndarray/strides2offset
*
* @example
* var strides2offset = require( '@stdlib/ndarray/base/strides2offset' );
*
* var shape = [ 2, 3, 10 ];
* var strides = [ 30, -10, 1 ];
*
* var offset = strides2offset( shape, strides );
* // returns 20
*/

/**
* Determine the order of a multidimensional array based on a provided stride array.
*
* @module @stdlib/ndarray/base/strides2order
*
* @example
* var strides2order = require( '@stdlib/ndarray/base/strides2order' );
*
* var order = strides2order( [ 2, 1 ] );
* // returns 'row-major'
*
* order = strides2order( [ 1, 2 ] );
* // returns 'column-major'
*
* order = strides2order( [ 1, 1, 1 ] );
* // returns 'both'
*
* order = strides2order( [ 2, 3, 1 ] );
* // returns 'none'
*/

/**
* Determines (nested) array dimensions.
*
* @param {Array} arr - array
* @throws {TypeError} must provide an array
* @returns {Array} array shape
*
* @example
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ];
*
* var shape = arrayShape( arr );
* // returns [ 3, 3 ]
*
* @example
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8 ] ];
*
* var shape = arrayShape( arr );
* // returns [ 3 ]
*
* @example
* var arr = [ [ 1, 2, 3 ], [ 4, 5, 6 ], null ];
*
* var shape = arrayShape( arr );
* // returns [ 3 ]
*/

/**
* Determines if an array is column-major contiguous.
*
* @private
* @param {string} order - **inferred** array order
* @param {boolean} contiguous - boolean indicating is an array is contiguous
* @returns {boolean} boolean indicating if an array is column-major contiguous
*/

/**
* Determines if an array is contiguous.
*
* @private
* @param {NonNegativeInteger} len - array length
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @param {NonNegativeInteger} offset - index offset
* @param {integer} iterationOrder - iteration order
* @returns {boolean} boolean indicating if an array is contiguous
*/

/**
* Determines if an array is row-major contiguous.
*
* @private
* @param {string} order - **inferred** array order
* @param {boolean} contiguous - boolean indicating is an array is contiguous
* @returns {boolean} boolean indicating if an array is row-major contiguous
*/

/**
* Determines the order of a multidimensional array based on a provided stride array.
*
* @param {IntegerArray} strides - stride array
* @returns {string} order
*
* @example
* var strides2order = require( '@stdlib/ndarray/base/strides2order' );
*
* var order = strides2order( [ 2, 1 ] );
* // returns 'row-major'
*
* order = strides2order( [ 1, 2 ] );
* // returns 'column-major'
*
* order = strides2order( [ 1, 1, 1 ] );
* // returns 'both'
*
* order = strides2order( [ 2, 3, 1 ] );
* // returns 'none'
*/

/**
* Dummy constructor.
*
* @private
*/

/**
* Escape a regular expression string or pattern.
*
* @module @stdlib/utils/escape-regexp-string
*
* @example
* var rescape = require( '@stdlib/utils/escape-regexp-string' );
*
* var str = rescape( '[A-Z]*' );
* // returns '\\[A\\-Z\\]\\*'
*/

/**
* Escapes a regular expression string.
*
* @param {string} str - regular expression string
* @throws {TypeError} first argument must be a string primitive
* @returns {string} escaped string
*
* @example
* var str = rescape( '[A-Z]*' );
* // returns '\\[A\\-Z\\]\\*'
*/

/**
* Expands a strides array to accommodate an expanded array shape (i.e., an array shape with prepended singleton dimensions).
*
* @private
* @param {NonNegativeInteger} ndims - number of dimensions
* @param {Array} shape - expanded array shape
* @param {Array} strides - strides array
* @param {string} order - memory layout order
* @returns {Array} output strides array
*
* @example
* var out = expandStrides( 4, [ 1, 1, 2, 2 ], [ 1, 2 ], 'column-major' );
* // returns [ 1, 1, 1, 2 ]
*
* @example
* var out = expandStrides( 4, [ 1, 1, 2, 2 ], [ 2, 1 ], 'row-major' );
* // returns [ 4, 4, 2, 1 ]
*/

/**
* Extends an array by the elements of another array.
*
* @private
* @param {Array} arr - input array
* @param {Array} ext - array to extend `arr` with
* @returns {Array} mutated input array
*
* @example
* var arr = [ 1, 2, 3 ];
* var out = extend( arr, [ 4, 5 ] );
* // returns [ 1, 2, 3, 4, 5 ]
*/

/**
* Fills an array-like object with zeros.
*
* @private
* @param {(Array|TypedArray|Buffer)} v - array-like object to fill
* @returns {(Array|TypedArray|Buffer)} input value
*
* @example
* var arr = zeros( new Array( 2 ) );
* // returns [ 0, 0 ]
*/

/**
* Flatten an array.
*
* @module @stdlib/utils/flatten-array
*
* @example
* var flattenArray = require( '@stdlib/utils/flatten-array' );
*
* var arr = [ 1, [2, [3, [4, [ 5 ], 6], 7], 8], 9 ];
*
* var out = flattenArray( arr );
* // returns [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*
* @example
* var flattenArray = require( '@stdlib/utils/flatten-array' );
*
* var flatten = flattenArray.factory( [2,2], {
*     'copy': false
* });
*
* var out = flatten( [[1,2],[3,4]] );
* // returns [ 1, 2, 3, 4 ]
*
* out = flatten( [[5,6],[7,8]] );
* // returns [ 5, 6, 7, 8 ]
*/

/**
* Flattens an array.
*
* @param {Array} arr - input array
* @param {Options} [options] - function options
* @param {NonNegativeInteger} [options.depth] - maximum depth to flatten
* @param {boolean} [options.copy=false] - boolean indicating whether to deep copy array elements
* @throws {TypeError} first argument must be an array
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Array} flattened array
*
* @example
* var arr = [ 1, [2, [3, [4, [ 5 ], 6], 7], 8], 9 ];
*
* var out = flattenArray( arr );
* // returns [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
*/

/**
* Generate a frequency table.
*
* @module @stdlib/utils/tabulate
*
* @example
* var tabulate = require( '@stdlib/utils/tabulate' );
*
* var arr = [ 'beep', 'boop', 'foo', 'beep' ];
*
* var out = tabulate( arr );
* // returns [ [ 'beep', 2, 0.5 ], [ 'boop', 1, 0.25 ], [ 'foo', 1, 0.25 ] ]
*/

/**
* Generate a stride array from an array shape.
*
* @module @stdlib/ndarray/base/shape2strides
*
* @example
* var shape2strides = require( '@stdlib/ndarray/base/shape2strides' );
*
* var strides = shape2strides( [ 3, 2 ], 'row-major' );
* // returns [ 2, 1 ]
*
* strides = shape2strides( [ 3, 2 ], 'column-major' );
* // returns [ 1, 3 ]
*/

/**
* Generates a frequency table.
*
* ## Notes
*
* -   The output is an array of arrays. Each sub-array corresponds to a unique value in the input collection and is structured as follows:
*
*     -   0: unique value
*     -   1: value count
*     -   2: frequency percentage
*
*
* @param {Collection} collection - input collection
* @throws {TypeError} first argument must be a collection
* @returns {(Array<Array>|Array)} frequency table
*
* @example
* var arr = [ 'beep', 'boop', 'foo', 'beep' ];
*
* var out = tabulate( arr );
* // returns [ [ 'beep', 2, 0.5 ], [ 'boop', 1, 0.25 ], [ 'foo', 1, 0.25 ] ]
*/

/**
* Generates a full table of safe casts for each ndarray data type.
*
* @private
* @returns {Object} table
*/

/**
* Generates a full table of same "kind" casts for each ndarray data type.
*
* @private
* @returns {Object} table
*/

/**
* Generates a stride array from an array shape.
*
* @param {(Array|TypedArray|Object)} [out] - output object
* @param {NonNegativeIntegerArray} shape - array shape
* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @returns {(Array|TypedArray|Object)} array strides
*
* @example
* var strides = shape2strides( [ 3, 2 ], 'row-major' );
* // returns [ 2, 1 ]
*
* strides = shape2strides( [ 3, 2 ], 'column-major' );
* // returns [ 1, 3 ]
*/

/**
* Generates a stride array from an array shape.
*
* @private
* @param {(Array|TypedArray|Object)} out - output object
* @param {NonNegativeIntegerArray} shape - array shape
* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @returns {(Array|TypedArray|Object)} array strides
*
* @example
* var strides = new Array( 2 );
*
* var out = shape2strides( strides, [ 3, 2 ], 'row-major' );
* // returns [ 2, 1 ]
*
* var bool = ( out === strides );
* // returns true
*
* out = shape2strides( strides, [ 3, 2 ], 'column-major' );
* // returns [ 1, 3 ]
*/

/**
* Generates a table of safe casts for each ndarray data type.
*
* @private
* @returns {Object} table
*/

/**
* Generates a table of same "kind" casts for each ndarray data type.
*
* @private
* @returns {Object} table
*/

/**
* Given a stride array, determine array iteration order.
*
* @module @stdlib/ndarray/base/iteration-order
*
* @example
* var iterationOrder = require( '@stdlib/ndarray/base/iteration-order' );
*
* var o = iterationOrder( [ 2, 1 ] );
* // returns 1
*
* o = iterationOrder( [ -2, 1 ] );
* // returns 0
*
* o = iterationOrder( [ -2, -1 ] );
* // returns -1
*/

/**
* Implement prototypical inheritance by replacing the prototype of one constructor with the prototype of another constructor.
*
* @module @stdlib/utils/inherit
*
* @example
* var inherit = require( '@stdlib/utils/inherit' );
*
* function Foo() {
*     return this;
* }
* Foo.prototype.beep = function beep() {
*     return 'boop';
* };
*
* function Bar() {
*     Foo.call( this );
*     return this;
* }
* inherit( Bar, Foo );
*
* var bar = new Bar();
* var v = bar.beep();
* // returns 'boop'
*/

/**
* Implements prototypical inheritance by replacing the prototype of one constructor with the prototype of another constructor.
*
* ## Notes
*
* -   This implementation is not designed to work with ES2015/ES6 classes. For ES2015/ES6 classes, use `class` with `extends`.
* -   For reference, see [node#3455](https://github.com/nodejs/node/pull/3455), [node#4179](https://github.com/nodejs/node/issues/4179), [node#3452](https://github.com/nodejs/node/issues/3452), and [node commit](https://github.com/nodejs/node/commit/29da8cf8d7ab8f66b9091ab22664067d4468461e#diff-3deb3f32958bb937ae05c6f3e4abbdf5).
*
*
* @param {(Object|Function)} ctor - constructor which will inherit
* @param {(Object|Function)} superCtor - super (parent) constructor
* @throws {TypeError} first argument must be either an object or a function which can inherit
* @throws {TypeError} second argument must be either an object or a function from which a constructor can inherit
* @throws {TypeError} second argument must have an inheritable prototype
* @returns {(Object|Function)} child constructor
*
* @example
* function Foo() {
*     return this;
* }
* Foo.prototype.beep = function beep() {
*     return 'boop';
* };
*
* function Bar() {
*     Foo.call( this );
*     return this;
* }
* inherit( Bar, Foo );
*
* var bar = new Bar();
* var v = bar.beep();
* // returns 'boop'
*/

/**
* Maximum double-precision floating-point number.
*
* ## Notes
*
* The maximum is given by
*
* ```tex
* 2^{1023} (2 - 2^{-52})
* ```
*
* @constant
* @type {number}
* @default 1.7976931348623157e+308
* @see [IEEE 754]{@link http://en.wikipedia.org/wiki/IEEE_754-1985}
*/

/**
* Maximum double-precision floating-point number.
*
* @module @stdlib/constants/math/float64-max
* @type {number}
*
* @example
* var FLOAT64_MAX = require( '@stdlib/constants/math/float64-max' );
* // returns 1.7976931348623157e+308
*/

/**
* Multidimensional array.
*
* @module @stdlib/ndarray/array
*
* @example
* var array = require( '@stdlib/ndarray/array' );
*
* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ] );
* // returns <ndarray>
*
* var v = arr.get( 0, 0 );
* // returns 1
*
* @example
* var array = require( '@stdlib/ndarray/array' );
*
* var opts = {
*     'dtype': 'generic',
*     'flatten': false
* };
*
* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ], opts );
* // returns <ndarray>
*
* var v = arr.get( 0 );
* // returns [ 1, 2 ]
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var array = require( '@stdlib/ndarray/array' );
*
* var opts = {
*     'shape': [ 2, 2 ]
* };
*
* var arr = array( new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] ), opts );
* // returns <ndarray>
*
* var v = arr.get( 0, 0 );
* // returns 1.0
*/

/**
* Prepends singleton dimensions in order to satisfy a minimum number of dimensions.
*
* @private
* @param {NonNegativeInteger} ndims - number of dimensions
* @param {Array} shape - array dimensions
* @param {NonNegativeInteger} ndmin - minimum number of dimensions
* @returns {Array} output shape array
*/

/**
* Recursively (and eagerly) attempts to resolve nested array dimensions.
*
* @private
* @param {Array} shape - output array
* @param {Array} arr - array
* @returns {Array} shape array
*/

/**
* Recursively flattens an array.
*
* @private
* @param {Array} out - output array
* @param {Array} arr - input array
* @param {NonNegativeInteger} depth - recursion depth
* @returns {Array} output array
*/

/**
* Recursively verifies that all nested arrays have consistent dimensions.
*
* @private
* @param {PositiveInteger} ndims - number of dimensions
* @param {Array} shape - shape array
* @param {NonNegativeInteger} d - dimension
* @param {Array} arr - array element to verify
* @param {boolean} flg - boolean indicating whether to continue recursing
* @returns {NonNegativeInteger} number of consistent dimensions
*/

/**
* Remove the last character of a string.
*
* @module @stdlib/string/remove-last
*
* @example
* var removeLast = require( '@stdlib/string/remove-last' );
*
* var out = removeLast( 'last man standing' );
* // returns 'last man standin'
*
* out = removeLast( 'Hidden Treasures' );
* // returns 'Hidden Treasure';
*/

/**
* Removes the last character of a string.
*
* @param {string} str - input string
* @throws {TypeError} must provide a string primitive
* @returns {string} updated string
*
* @example
* var out = removeLast( 'last man standing' );
* // returns 'last man standin'
*
* @example
* var out = removeLast( 'presidential election' );
* // returns 'presidential electio'
*
* @example
* var out = removeLast( 'javaScript' );
* // returns 'javaScrip'
*
* @example
* var out = removeLast( 'Hidden Treasures' );
* // returns 'Hidden Treasure'
*/

/**
* Replace search occurrences with a replacement string.
*
* @module @stdlib/string/replace
*
* @example
* var replace = require( '@stdlib/string/replace' );
*
* var str = 'beep';
* var out = replace( str, 'e', 'o' );
* // returns 'boop'
*
* str = 'Hello World';
* out = replace( str, /world/i, 'Mr. President' );
* // returns 'Hello Mr. President'
*/

/**
* Replace search occurrences with a replacement string.
*
* @param {string} str - input string
* @param {(string|RegExp)} search - search expression
* @param {(string|Function)} newval - replacement value or function
* @throws {TypeError} first argument must be a string primitive
* @throws {TypeError} second argument argument must be a string primitive or regular expression
* @throws {TypeError} third argument must be a string primitive or function
* @returns {string} new string containing replacement(s)
*
* @example
* var str = 'beep';
* var out = replace( str, 'e', 'o' );
* // returns 'boop'
*
* @example
* var str = 'Hello World';
* var out = replace( str, /world/i, 'Mr. President' );
* // returns 'Hello Mr. President'
*
* @example
* var capitalize = require( '@stdlib/string/capitalize' );
*
* var str = 'Oranges and lemons say the bells of St. Clement\'s';
*
* function replacer( match, p1 ) {
*     return capitalize( p1 );
* }
*
* var out = replace( str, /([^\s]*)/gi, replacer);
* // returns 'Oranges And Lemons Say The Bells Of St. Clement\'s'
*/

/**
* Restrict an index to the interval `[0,max]`.
*
* @module @stdlib/ndarray/base/clamp-index
*
* @example
* var clampIndex = require( '@stdlib/ndarray/base/clamp-index' );
*
* var idx = clampIndex( -1, 10 );
* // returns 0
*
* idx = clampIndex( 15, 10 );
* // returns 10
*
* idx = clampIndex( 5, 10 );
* // returns 5
*/

/**
* Restricts an index to the interval `[0,max]`.
*
* @param {integer} idx - index
* @param {NonNegativeInteger} max - maximum index
* @returns {NonNegativeInteger} index
*
* @example
* var idx = clampIndex( -1, 10 );
* // returns 0
*
* idx = clampIndex( 15, 10 );
* // returns 10
*
* idx = clampIndex( 5, 10 );
* // returns 5
*/

/**
* Return a boolean indicating if a buffer length is compatible with provided ndarray meta data.
*
* @module @stdlib/ndarray/base/assert/is-stride-offset-buffer-compatible
*
* @example
* var isBufferLengthCompatible = require( '@stdlib/ndarray/base/assert/is-buffer-length-compatible' );
*
* var shape = [ 2, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var bool = isBufferLengthCompatible( 4, shape, strides, offset );
* // returns true
*
* @example
* var isBufferLengthCompatible = require( '@stdlib/ndarray/base/assert/is-buffer-length-compatible' );
*
* var shape = [ 2, 2 ];
* var strides = [ 2, 1 ];
* var offset = 2;
*
* var bool = isBufferLengthCompatible( 4, shape, strides, offset );
* // returns false
*/

/**
* Return a function which tests if every element in an array-like object passes a test condition.
*
* @module @stdlib/assert/tools/array-like-function
*
* @example
* var isOdd = require( '@stdlib/assert/is-odd' );
* var arraylikefcn = require( '@stdlib/assert/tools/array-like-function' );
*
* var arr1 = [ 1, 3, 5, 7 ];
* var arr2 = [ 3, 5, 8 ];
*
* var validate = arraylikefcn( isOdd );
*
* var bool = validate( arr1 );
* // returns true
*
* bool = validate( arr2 );
* // returns false
*/

/**
* Return a list of ndarray casting modes.
*
* @module @stdlib/ndarray/casting-modes
*
* @example
* var modes = require( '@stdlib/ndarray/casting-modes' );
*
* var list = modes();
* // returns [ 'none', 'equiv', 'safe', 'same-kind', 'unsafe' ]
*/

/**
* Return a list of ndarray data types to which a provided ndarray data type can be safely cast or cast within the same "kind".
*
* @module @stdlib/ndarray/same-kind-casts
*
* @example
* var sameKindCasts = require( '@stdlib/ndarray/same-kind-casts' );
*
* var list = sameKindCasts( 'float32' );
* // returns [...]
*/

/**
* Return a list of ndarray data types to which a provided ndarray data type can be safely cast.
*
* @module @stdlib/ndarray/safe-casts
*
* @example
* var safeCasts = require( '@stdlib/ndarray/safe-casts' );
*
* var list = safeCasts( 'float32' );
* // returns [...]
*/

/**
* Return a list of ndarray data types.
*
* @module @stdlib/ndarray/dtypes
*
* @example
* var dtypes = require( '@stdlib/ndarray/dtypes' );
*
* var list = dtypes();
* // returns [...]
*/

/**
* Return a list of ndarray index modes.
*
* @module @stdlib/ndarray/index-modes
*
* @example
* var modes = require( '@stdlib/ndarray/index-modes' );
*
* var list = modes();
* // returns [ 'throw', 'clamp', 'wrap' ]
*/

/**
* Return a list of ndarray orders.
*
* @module @stdlib/ndarray/orders
*
* @example
* var orders = require( '@stdlib/ndarray/orders' );
*
* var list = orders();
* // returns [ 'row-major', 'column-major' ]
*/

/**
* Return an index given an index mode.
*
* @module @stdlib/ndarray/base/ind
*
* @example
* var ind = require( '@stdlib/ndarray/base/ind' );
*
* var idx = ind( -1, 10, 'wrap' );
* // returns 10
*
* idx = ind( 14, 10, 'wrap' );
* // returns 3
*
* idx = ind( 6, 10, 'wrap' );
* // returns 6
*
* @example
* var ind = require( '@stdlib/ndarray/base/ind' );
*
* var idx = ind( -1, 10, 'clamp' );
* // returns 0
*
* idx = ind( 14, 10, 'clamp' );
* // returns 10
*
* idx = ind( 6, 10, 'clamp' );
* // returns 6
*
* @example
* var ind = require( '@stdlib/ndarray/base/ind' );
*
* var idx = ind( 1, 10, 'throw' );
* // returns 1
*
* idx = ind( 14, 10, 'throw' );
* // throws <RangeError>
*
* idx = ind( -1, 10, 'throw' );
* // throws <RangeError>
*/

/**
* Return the data type of an ndarray data buffer.
*
* @module @stdlib/ndarray/base/buffer-dtype
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var dtype = require( '@stdlib/ndarray/base/buffer-dtype' );
*
* var buf = new Float64Array( 10 );
*
* var dt = dtype( buf );
* // returns 'float64'
*
* dt = dtype( {} );
* // returns 'generic'
*
* dt = dtype( 'beep' );
* // returns null
*/

/**
* Return the number of bytes per element provided an underlying array data type.
*
* @module @stdlib/ndarray/base/bytes-per-element
*
* @example
* var bytesPerElement = require( '@stdlib/ndarray/base/bytes-per-element' );
*
* var nbytes = bytesPerElement( 'float64' );
* // returns 8
*
* nbytes = bytesPerElement( 'generic' );
* // returns null
*/

/**
* Return the number of elements in an array.
*
* @module @stdlib/ndarray/base/numel
*
* @example
* var numel = require( '@stdlib/ndarray/base/numel' );
*
* var n = numel( [ 3, 3, 3 ] );
* // returns 27
*/

/**
* Returns a boolean indicating if a buffer length is compatible with provided ndarray meta data.
*
* @param {NonNegativeInteger} len - buffer length
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @param {NonNegativeInteger} offset - index offset
* @returns {boolean} boolean indicating if a buffer length is compatible
*
* @example
* var shape = [ 2, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var bool = isBufferLengthCompatible( 4, shape, strides, offset );
* // returns true
*
* @example
* var shape = [ 2, 2 ];
* var strides = [ 2, 1 ];
* var offset = 2;
*
* var bool = isBufferLengthCompatible( 4, shape, strides, offset );
* // returns false
*/

/**
* Returns a boolean indicating if a provided ndarray data type can be cast to another ndarray data type according to a specified casting mode.
*
* @param {string} from - ndarray data type
* @param {string} to - ndarray data type
* @param {string} casting - ndarray casting mode
* @returns {boolean} boolean indicating if a data type can be cast to another data type
*
* @example
* var bool = isAllowedCast( 'float32', 'float64', 'safe' );
* // returns true
*
* bool = isAllowedCast( 'float64', 'int32', 'safe' );
* // returns false
*/

/**
* Returns a boolean indicating if a provided ndarray data type can be safely cast to another ndarray data type.
*
* @param {string} from - ndarray data type
* @param {string} to - ndarray data type
* @returns {boolean} boolean indicating if a data type can be safely cast to another data type
*
* @example
* var bool = isSafeCast( 'float32', 'float64' );
* // returns true
*
* bool = isSafeCast( 'float64', 'int32' );
* // returns false
*/

/**
* Returns a boolean indicating if a provided ndarray data type can be safely cast to, or is of the same "kind" as, another ndarray data type.
*
* @param {string} from - ndarray data type
* @param {string} to - ndarray data type
* @returns {boolean} boolean indicating if a data type can be cast to another data type
*
* @example
* var bool = isSameKindCast( 'float32', 'float64' );
* // returns true
*
* bool = isSameKindCast( 'uint16', 'int16' );
* // returns false
*/

/**
* Returns a cache key.
*
* @private
* @param {string} dtype - data type
* @param {Options} opts - function options
* @param {boolean} opts.codegen - boolean indicating whether to use code generation
* @param {string} opts.mode - specifies how to handle indices which exceed array dimensions
* @param {StringArray} opts.submode - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @returns {string} cache key
*
* @example
* var opts = {
*     'codegen': true,
*     'mode': 'throw',
*     'submode': [ 'throw' ]
* };
* var key = getKey( 'float64', opts );
* // returns 'float64;codegen=true,mode="throw",submode=["throw"]'
*/

/**
* Returns a cache key.
*
* @private
* @param {string} dtype - data type
* @param {Options} opts - function options
* @param {boolean} opts.codegen - boolean indicating whether to use code generation
* @returns {string} cache key
*
* @example
* var opts = {
*     'codegen': true
* };
* var key = getKey( 'float64', opts );
* // returns 'float64;codegen=true'
*/

/**
* Returns a constructor cache.
*
* ## Notes
*
* -   Should return something similar to the following:
*
*     ```text
*     {
*         "float64;codegen=true": [],
*         "float64;codegen=false": [],
*         "float32;codegen=true": [],
*         "float32;codegen=false": [],
*         ...
*     }
*     ```
*
* @private
* @returns {Object} constructor cache
*/

/**
* Returns a constructor cache.
*
* @private
* @returns {Object} constructor cache
*/

/**
* Returns a function for flattening arrays having specified dimensions.
*
* @param {PositiveIntegerArray} dims - dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.copy=false] - boolean indicating whether to deep copy array elements
* @throws {TypeError} first argument must be an array of positive integers
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Function} flatten function
*
* @example
* var flatten = factory( [2,2], {
*     'copy': false
* });
*
* var out = flatten( [[1,2],[3,4]] );
* // returns [ 1, 2, 3, 4 ]
*
* out = flatten( [[5,6],[7,8]] );
* // returns [ 5, 6, 7, 8 ]
*/

/**
* Returns a function to flatten an array and deep copy.
*
* @private
* @param {Function} flatten - flatten function
* @returns {Function} wrapped flatten function
*/

/**
* Returns a function to flatten an array containing elements all having the same dimensions.
*
* @private
* @param {PositiveIntegerArray} dims - dimensions
* @returns {Function} flatten function
*/

/**
* Returns a function to flatten an array.
*
* @private
* @param {Function} flatten - flatten function
* @returns {Function} wrapped flatten function
*/

/**
* Returns a function which tests if every element in an array-like object passes a test condition.
*
* @param {Function} predicate - function to apply
* @throws {TypeError} must provide a function
* @returns {Function} an array-like object function
*
* @example
* var isOdd = require( '@stdlib/assert/is-odd' );
*
* var arr1 = [ 1, 3, 5, 7 ];
* var arr2 = [ 3, 5, 8 ];
*
* var validate = arraylikefcn( isOdd );
*
* var bool = validate( arr1 );
* // returns true
*
* bool = validate( arr2 );
* // returns false
*/

/**
* Returns a getter function for arrays having a specified number of dimensions.
*
* @private
* @param {PositiveInteger} ndims - array dimensions
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} getter
*
* @example
* var f = get( 3 );
* // returns <Function>
*/

/**
* Returns a getter function for arrays having a specified number of dimensions.
*
* @private
* @param {PositiveInteger} ndims - array dimensions
* @returns {Function} getter
*
* @example
* var f = get( 3 );
* // returns <Function>
*/

/**
* Returns a list of ndarray casting modes.
*
* @returns {StringArray} list of ndarray casting modes
*
* @example
* var list = modes();
* // returns [ 'none', 'equiv', 'safe', 'same-kind', 'unsafe' ]
*/

/**
* Returns a list of ndarray data types to which a provided ndarray data type can be safely cast or cast within the same "kind".
*
* @param {string} [dtype] - ndarray data type
* @returns {(Object|StringArray|null)} list of ndarray data types or null
*
* @example
* var list = sameKindCasts( 'float32' );
* // returns [...]
*/

/**
* Returns a list of ndarray data types to which a provided ndarray data type can be safely cast.
*
* @param {string} [dtype] - ndarray data type
* @returns {(Object|StringArray|null)} list of ndarray data types or null
*
* @example
* var list = safeCasts( 'float32' );
* // returns [...]
*/

/**
* Returns a list of ndarray data types.
*
* @returns {StringArray} list of ndarray data types
*
* @example
* var list = dtypes();
* // returns [...]
*/

/**
* Returns a list of ndarray index modes.
*
* @returns {StringArray} list of ndarray index modes
*
* @example
* var list = modes();
* // returns [ 'throw', 'clamp', 'wrap' ]
*/

/**
* Returns a list of ndarray orders.
*
* @returns {StringArray} list of ndarray orders
*
* @example
* var list = orders();
* // returns [ 'row-major', 'column-major' ]
*/

/**
* Returns a memoized ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @throws {TypeError} first argument must be a supported ndarray data type
* @throws {TypeError} second argument must be a number having a positive integer value
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Function} memoized ndarray constructor
*
* @example
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Returns a memoized ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @returns {Function} memoized ndarray constructor
*
* @example
* var f1 = ctor( 'float64', 3 );
* // returns <Function>
*
* var f2 = ctor( 'float64', 3 );
* // returns <Function>
*
* var bool = ( f1 === f2 );
* // returns true
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = f1( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Returns a method for getting an array element located at a specified linear index.
*
* @private
* @param {Function} base - parent (super) method
* @param {string} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method for getting an array element
*/

/**
* Returns a method for returning an array element.
*
* @private
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method for returning an array element
*/

/**
* Returns a method for setting an array element located at a specified linear index.
*
* @private
* @param {Function} base - parent (super) method
* @param {string} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method for setting an array element
*/

/**
* Returns a method for setting an array element.
*
* @private
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method for setting an array element
*/

/**
* Returns a method to return an array element.
*
* @private
* @param {PositiveInteger} ndims - number of dimensions
* @param {boolean} codegen - boolean indicating whether to use code generation
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method to return an array element
*/

/**
* Returns a method to set an array element.
*
* @private
* @param {PositiveInteger} ndims - number of dimensions
* @param {boolean} codegen - boolean indicating whether to use code generation
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} method to set an array element
*/

/**
* Returns a multidimensional array.
*
* @param {(ArrayLikeObject|TypedArrayLike|Buffer|ndarrayLike)} [buffer] - data source
* @param {Options} [options] - function options
* @param {(ArrayLikeObject|TypedArrayLike|Buffer|ndarrayLike)} [options.buffer] - data source
* @param {string} [options.dtype="float64"] - underlying storage data type (if the input data is not of the same type, this option specifies the data type to which to cast the input data)
* @param {string} [options.order="row-major"] - specifies the memory layout of the array as either row-major (C-style) or column-major (Fortran-style)
* @param {NonNegativeIntegerArray} [options.shape] - array shape
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @param {boolean} [options.copy=false] - boolean indicating whether to copy source data to a new data buffer
* @param {boolean} [options.flatten=true] - boolean indicating whether to automatically flatten generic array data sources
* @param {NonNegativeInteger} [options.ndmin=0] - minimum number of dimensions
* @param {string} [options.casting="safe"] - casting rule used to determine what constitutes an acceptable cast
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {Error} must provide either an array shape, data source, or both
* @throws {Error} invalid cast
* @throws {RangeError} data source must be compatible with specified meta data
* @returns {ndarray} ndarray instance
*
* @example
* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ] );
* // returns <ndarray>
*
* var v = arr.get( 0, 0 );
* // returns 1
*
* @example
* var opts = {
*     'dtype': 'generic',
*     'flatten': false
* };
*
* var arr = array( [ [ 1, 2 ], [ 3, 4 ] ], opts );
* // returns <ndarray>
*
* var v = arr.get( 0 );
* // returns [ 1, 2 ]
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
*
* var opts = {
*     'shape': [ 2, 2 ]
* };
*
* var arr = array( new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] ), opts );
* // returns <ndarray>
*
* var v = arr.get( 0, 0 );
* // returns 1.0
*/

/**
* Returns a setter function for arrays having a specified number of dimensions.
*
* @private
* @param {PositiveInteger} ndims - array dimensions
* @param {StringArray} mode - specifies how to handle indices which exceed array dimensions
* @returns {Function} setter
*
* @example
* var f = set( 3 );
* // returns <Function>
*/

/**
* Returns a setter function for arrays having a specified number of dimensions.
*
* @private
* @param {PositiveInteger} ndims - array dimensions
* @returns {Function} setter
*
* @example
* var f = set( 3 );
* // returns <Function>
*/

/**
* Returns a zero-filled contiguous linear ndarray data buffer.
*
* @param {string} dtype - data type
* @param {NonNegativeInteger} size - buffer size
* @returns {(Array|TypedArray|Buffer)|null} data buffer
*
* @example
* var buf = buffer( 'float64', 3 );
* // returns <Float64Array>[ 0.0, 0.0, 0.0 ]
*/

/**
* Returns an array element located a specified linear view index.
*
* @private
* @param {integer} idx - linear view index
* @returns {*} array element
*/

/**
* Returns an array element.
*
* @private
* @param {...integer} idx - indices
* @returns {*} array element
*/

/**
* Returns an index given an index mode.
*
* @param {integer} idx - index
* @param {NonNegativeInteger} max - maximum index
* @param {string} mode - specifies how to handle an index outside the interval `[0,max]`
* @throws {RangeError} index out-of-bounds
* @returns {integer} index
*
* @example
* var idx = ind( 2, 9, 'clamp' );
* // returns 2
*
* idx = ind( 10, 9, 'clamp' );
* // returns 9
*
* idx = ind( -1, 9, 'clamp' );
* // returns 0
*
* @example
* var idx = ind( 2, 9, 'wrap' );
* // returns 2
*
* idx = ind( 10, 9, 'wrap' );
* // returns 0
*
* idx = ind( -1, 9, 'wrap' );
* // returns 9
*
* @example
* var idx = ind( 2, 9, 'throw' );
* // returns 2
*
* idx = ind( 10, 9, 'throw' );
* // throws <RangeError>
*
* idx = ind( -1, 9, 'throw' );
* // throws <RangeError>
*/

/**
* Returns an ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @throws {TypeError} first argument must be a supported ndarray data type
* @throws {TypeError} second argument must be a number having a positive integer value
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {RangeError} too many dimensions
* @returns {Function} ndarray constructor
*
* @example
* var ndarray = ctor( 'generic', 2 );
* // returns <Function>
*
* var buffer = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Returns an ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @returns {Function} ndarray constructor
*
* @example
* var ndarray = ctor( 'float64', 3 );
* // returns <Function>
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/

/**
* Returns an ndarray data buffer constructor.
*
* @param {string} dtype - data type
* @returns {(Function|null)} data buffer constructor or null
*
* @example
* var ctor = ctors( 'float64' );
* // returns <Function>
*
* @example
* var ctor = ctors( 'float' );
* // returns null
*/

/**
* Returns array iteration order.
*
* ## Notes
*
* -   Return value key:
*
*     -   `0`: unordered (i.e., strides of mixed sign; e.g., `[ 9, -3, 1 ]`)
*     -   `1`: ordered left-to-right (i.e., all nonnegative strides)
*     -   `-1`: ordered right-to-left (i.e., all negative strides)
*
* @param {IntegerArray} strides - stride array
* @returns {integer} iteration order
*
* @example
* var o = iterationOrder( [ 2, 1 ] );
* // returns 1
*
* o = iterationOrder( [ -2, 1 ] );
* // returns 0
*
* o = iterationOrder( [ -2, -1 ] );
* // returns -1
*/

/**
* Returns the data type of an ndarray data buffer.
*
* @param {*} value - input value
* @returns {(string|null)} data type
*
* @example
* var dt = dtype( [ 1, 2, 3 ] );
* // returns 'generic'
*
* var dt = dtype( 'beep' );
* // returns null
*/

/**
* Returns the index offset which specifies the location of the first indexed value in a multidimensional array based on a stride array.
*
* @param {NonNegativeIntegerArray} shape - array shape
* @param {IntegerArray} strides - stride array
* @returns {NonNegativeInteger} offset - offset
*
* @example
* var shape = [ 2, 3, 10 ];
* var strides = [ 30, -10, 1 ];
*
* var offset = strides2offset( shape, strides );
* // returns 20
*/

/**
* Returns the number of bytes per element provided an underlying array data type.
*
* @param {string} dtype - data type
* @returns {(NonNegativeInteger|null)} number of bytes per element
*
* @example
* var nbytes = bytesPerElement( 'float64' );
* // returns 8
*
* nbytes = bytesPerElement( 'generic' );
* // returns null
*/

/**
* Returns the number of elements in an array.
*
* @param {(NonNegativeIntegerArray|EmptyArray)} shape - array shape
* @returns {NonNegativeInteger} number of elements
*
* @example
* var n = numel( [ 3, 3, 3 ] );
* // returns 27
*/

/**
* Serializes an ndarray as a JSON object.
*
* ## Notes
*
* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
*
* @private
* @returns {Object} JSON representation
*/

/**
* Serializes an ndarray as a string.
*
* ## Notes
*
* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
*
* @private
* @returns {string} string representation
*/

/**
* Sets an array element located a specified linear view index.
*
* @private
* @param {integer} idx - linear view index
* @param {*} v - value to set
* @returns {ndarray} ndarray instance
*/

/**
* Sets an array element.
*
* @private
* @param {...integer} idx - indices
* @param {*} v - value to set
* @returns {ndarray} ndarray instance
*/

/**
* Test if a value is a regular expression.
*
* @module @stdlib/assert/is-regexp
*
* @example
* var isRegExp = require( '@stdlib/assert/is-regexp' );
*
* var bool = isRegExp( /\.+/ );
* // returns true
*
* bool = isRegExp( {} );
* // returns false
*/

/**
* Test if a value is an array-like object containing only integers.
*
* @module @stdlib/assert/is-integer-array
*
* @example
* var isIntegerArray = require( '@stdlib/assert/is-integer-array' );
*
* var bool = isIntegerArray( [ -3.0, new Number(0.0), 2.0 ] );
* // returns true
*
* bool = isIntegerArray( [ -3.0, '3.0' ] );
* // returns false
*
* @example
* var isIntegerArray = require( '@stdlib/assert/is-integer-array' ).primitives;
*
* var bool = isIntegerArray( [ -1.0, 10.0 ] );
* // returns true
*
* bool = isIntegerArray( [ -1.0, 0.0, 5.0 ] );
* // returns true
*
* bool = isIntegerArray( [ -3.0, new Number(-1.0) ] );
* // returns false
*
* @example
* var isIntegerArray = require( '@stdlib/assert/is-integer-array' ).objects;
*
* var bool = isIntegerArray( [ new Number(1.0), new Number(3.0) ] );
* // returns true
*
* bool = isIntegerArray( [ -1.0, 0.0, 3.0 ] );
* // returns false
*
* bool = isIntegerArray( [ 3.0, new Number(-1.0) ] );
* // returns false
*/

/**
* Test if a value is an array-like object containing only nonnegative integers.
*
* @module @stdlib/assert/is-nonnegative-integer-array
*
* @example
* var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' );
*
* var bool = isNonNegativeIntegerArray( [ 3.0, new Number(3.0) ] );
* // returns true
*
* bool = isNonNegativeIntegerArray( [ 3.0, '3.0' ] );
* // returns false
*
* @example
* var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' ).primitives;
*
* var bool = isNonNegativeIntegerArray( [ 1.0, 0.0, 10.0 ] );
* // returns true
*
* bool = isNonNegativeIntegerArray( [ 3.0, new Number(1.0) ] );
* // returns false
*
* @example
* var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' ).objects;
*
* var bool = isNonNegativeIntegerArray( [ new Number(3.0), new Number(1.0) ] );
* // returns true
*
* bool = isNonNegativeIntegerArray( [ 1.0, 0.0, 10.0 ] );
* // returns false
*/

/**
* Test if a value is an array-like object containing only positive integers.
*
* @module @stdlib/assert/is-positive-integer-array
*
* @example
* var isPositiveIntegerArray = require( '@stdlib/assert/is-positive-integer-array' );
*
* var bool = isPositiveIntegerArray( [ 3.0, new Number(3.0) ] );
* // returns true
*
* bool = isPositiveIntegerArray( [ 3.0, '3.0' ] );
* // returns false
*
* @example
* var isPositiveIntegerArray = require( '@stdlib/assert/is-positive-integer-array' ).primitives;
*
* var bool = isPositiveIntegerArray( [ 1.0, 2.0, 10.0 ] );
* // returns true
*
* bool = isPositiveIntegerArray( [ 3.0, new Number(1.0) ] );
* // returns false
*
* @example
* var isPositiveIntegerArray = require( '@stdlib/assert/is-positive-integer-array' ).objects;
*
* var bool = isPositiveIntegerArray( [ new Number(3.0), new Number(1.0) ] );
* // returns true
*
* bool = isPositiveIntegerArray( [ 1.0, 2.0, 10.0 ] );
* // returns false
*/

/**
* Test if a value is an array-like object.
*
* @module @stdlib/assert/is-array-like-object
*
* @example
* var isArrayLikeObject = require( '@stdlib/assert/is-array-like-object' );
*
* var bool = isArrayLikeObject( [] );
* // returns true
*
* bool = isArrayLikeObject( { 'length':10 } );
* // returns true
*
* bool = isArrayLikeObject( 'beep' );
* // returns false
*/

/**
* Test if a value is an empty string.
*
* @module @stdlib/assert/is-empty-string
*
* @example
* var isEmptyString = require( '@stdlib/assert/is-empty-string' );
*
* var bool = isEmptyString( '' );
* // returns true
*
* bool = isEmptyString( 'beep' );
* // returns false
*
* bool = isEmptyString( [] );
* // returns false
*
* @example
* var isEmptyString = require( '@stdlib/assert/is-empty-string' ).isObject;
*
* var bool = isEmptyString( new String( '' ) );
* // returns true
*
* bool = isEmptyString( '' );
* // returns false
*
* @example
* var isEmptyString = require( '@stdlib/assert/is-empty-string' ).isPrimitive;
*
* var bool = isEmptyString( '' );
* // returns true
*
* bool = isEmptyString( new String( '' ) );
* // returns false
*/

/**
* Test if a value is ndarray-like.
*
* @module @stdlib/assert/is-ndarray-like
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
* var isndarrayLike = require( '@stdlib/assert/is-ndarray-like' );
*
* var ndarray = ctor( 'generic', 2 );
*
* var arr = ndarray( [ 0, 0, 0, 0 ], [ 2, 2 ], [ 2, 1 ], 0, 'row-major' );
*
* var bool = isndarrayLike( arr );
* // returns true
*
* bool = isndarrayLike( [] );
* // returns false
*/

/**
* Test if a value is typed-array-like.
*
* @module @stdlib/assert/is-typed-array-like
*
* @example
* var Int16Array = require( '@stdlib/array/int16' );
* var isTypedArrayLike = require( '@stdlib/assert/is-typed-array-like' );
*
* var bool = isTypedArrayLike( new Int16Array() );
* // returns true
*
* bool = isTypedArrayLike({
*	'length': 10,
*	'byteOffset': 0,
*	'byteLength': 10,
*	'BYTES_PER_ELEMENT': 4
* });
* // returns true
*/

/**
* Test if two arguments are strictly equal.
*
* @module @stdlib/assert/is-strict-equal
*
* @example
* var isStrictEqual = require( '@stdlib/assert/is-strict-equal' );
*
* var bool = isStrictEqual( true, true );
* // returns true
*
* bool = isStrictEqual( 3.14, 3.14 );
* // returns true
*
* bool = isStrictEqual( {}, {} );
* // returns false
*
* bool = isStrictEqual( -0.0, -0.0 );
* // returns true
*
* bool = isStrictEqual( -0.0, 0.0 );
* // returns false
*
* bool = isStrictEqual( NaN, NaN );
* // returns false
*
* bool = isStrictEqual( [], [] );
* // returns false
*/

/**
* Test whether an input value is a supported ndarray casting mode.
*
* @module @stdlib/ndarray/base/assert/is-casting-mode
*
* @example
* var isCastingMode = require( '@stdlib/ndarray/base/assert/is-casting-mode' );
*
* var bool = isCastingMode( 'none' );
* // returns true
*
* bool = isCastingMode( 'equiv' );
* // returns true
*
* bool = isCastingMode( 'safe' );
* // returns true
*
* bool = isCastingMode( 'same-kind' );
* // returns true
*
* bool = isCastingMode( 'unsafe' );
* // returns true
*
* bool = isCastingMode( 'foo' );
* // returns false
*/

/**
* Test whether an input value is a supported ndarray data type.
*
* @module @stdlib/ndarray/base/assert/is-data-type
*
* @example
* var isDataType = require( '@stdlib/ndarray/base/assert/is-data-type' );
*
* var bool = isDataType( 'binary' );
* // returns true
*
* bool = isDataType( 'float32' );
* // returns true
*
* bool = isDataType( 'float64' );
* // returns true
*
* bool = isDataType( 'generic' );
* // returns true
*
* bool = isDataType( 'int16' );
* // returns true
*
* bool = isDataType( 'int32' );
* // returns true
*
* bool = isDataType( 'int8' );
* // returns true
*
* bool = isDataType( 'uint16' );
* // returns true
*
* bool = isDataType( 'uint32' );
* // returns true
*
* bool = isDataType( 'uint8' );
* // returns true
*
* bool = isDataType( 'uint8c' );
* // returns true
*
* bool = isDataType( 'foo' );
* // returns false
*/

/**
* Test whether an input value is a supported ndarray index mode.
*
* @module @stdlib/ndarray/base/assert/is-index-mode
*
* @example
* var isIndexMode = require( '@stdlib/ndarray/base/assert/is-index-mode' );
*
* var bool = isIndexMode( 'wrap' );
* // returns true
*
* bool = isIndexMode( 'clamp' );
* // returns true
*
* bool = isIndexMode( 'throw' );
* // returns true
*
* bool = isIndexMode( 'foo' );
* // returns false
*/

/**
* Test whether an input value is an ndarray order.
*
* @module @stdlib/ndarray/base/assert/is-order
*
* @example
* var isOrder = require( '@stdlib/ndarray/base/assert/is-order' );
*
* var bool = isOrder( 'row-major' );
* // returns true
*
* bool = isOrder( 'column-major' );
* // returns true
*
* bool = isOrder( 'foo' );
* // returns false
*/

/**
* Tests (loosely) if an input value is an array-like object.
*
* @private
* @param {*} value - value to test
* @returns {boolean} boolean indicating if an input value is an array-like object
*
* @example
* var bool = isArrayLikeObject( [] );
* // returns true
*
* @example
* var bool = isArrayLikeObject( '' );
* // returns false
*/

/**
* Tests if a value is a regular expression.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is a regular expression
*
* @example
* var bool = isRegExp( /\.+/ );
* // returns true
*
* @example
* var bool = isRegExp( {} );
* // returns false
*/

/**
* Tests if a value is an array-like object.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is an array-like object
*
* @example
* var bool = isArrayLikeObject( [] );
* // returns true
*
* @example
* var bool = isArrayLikeObject( { 'length':10 } );
* // returns true
*
* @example
* var bool = isArrayLikeObject( 'beep' );
* // returns false
*/

/**
* Tests if a value is an empty string object.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an empty string object
*
* @example
* var bool = isEmptyString( '' );
* // returns false
*
* @example
* var bool = isEmptyString( new String( '' ) );
* // returns true
*
* @example
* var bool = isEmptyString( [] );
* // returns false
*/

/**
* Tests if a value is an empty string primitive.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an empty string primitive
*
* @example
* var bool = isEmptyString( '' );
* // returns true
*
* @example
* var bool = isEmptyString( 'beep' );
* // returns false
*
* @example
* var bool = isEmptyString( [] );
* // returns false
*/

/**
* Tests if a value is an empty string.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating whether value is an empty string
*
* @example
* var bool = isEmptyString( '' );
* // returns true
*
* @example
* var bool = isEmptyString( 'beep' );
* // returns false
*
* @example
* var bool = isEmptyString( [] );
* // returns false
*/

/**
* Tests if a value is ndarray-like.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating if a value is ndarray-like
*
* @example
* var ctor = require( '@stdlib/ndarray/ctor' );
*
* var ndarray = ctor( 'generic', 2 );
* var arr = ndarray( [ 0, 0, 0, 0 ], [ 2, 2 ], [ 2, 1 ], 0, 'row-major' );
*
* var bool = isndarrayLike( arr );
* // returns true
*
* bool = isndarrayLike( [] );
* // returns false
*/

/**
* Tests if a value is typed-array-like.
*
* @param {*} value - value to test
* @returns {boolean} boolean indicating if a value is typed-array-like
*
* @example
* var arr = {
*	'BYTES_PER_ELEMENT': 8,
*	'length': 10,
*	'byteOffset': 0,
*	'byteLength': 10
* };
* var val = isTypedArrayLike( arr );
* // returns true
*
* @example
* var Int8Array = require( '@stdlib/array/int8' );
*
* var val = isTypedArrayLike( new Int8Array( 4 ) );
* // returns true
*
* @example
* var val = isTypedArrayLike( [] );
* // returns false
*
* @example
* var val = isTypedArrayLike( {} );
* // returns false
*
* @example
* var val = isTypedArrayLike( null );
* // returns false
*
* @example
* var val = isTypedArrayLike( 'beep' );
* // returns false
*/

/**
* Tests if two arguments are strictly equal.
*
* ## Notes
*
* -   In contrast to the strict equality operator `===`, `-0` and `+0` are distinguishable.
*
*
* @param {*} a - first input value
* @param {*} b - second input value
* @returns {boolean} boolean indicating whether two arguments are strictly equal
*
* @example
* var bool = isStrictEqual( true, true );
* // returns true
*
* @example
* var bool = isStrictEqual( 3.14, 3.14 );
* // returns true
*
* @example
* var bool = isStrictEqual( {}, {} );
* // returns false
*
* @example
* var bool = isStrictEqual( -0.0, -0.0 );
* // returns true
*
* @example
* var bool = isStrictEqual( -0.0, 0.0 );
* // returns false
*
* @example
* var bool = isStrictEqual( NaN, NaN );
* // returns false
*
* @example
* var bool = isStrictEqual( [], [] );
* // returns false
*/

/**
* Tests that a value is a valid constructor.
*
* @private
* @param {*} value - value to test
* @returns {(Error|null)} error object or null
*
* @example
* var ctor = function ctor() {};
*
* var err = validate( ctor );
* // returns null
*
* err = validate( null );
* // returns <TypeError>
*/

/**
* Tests whether an input value is a supported ndarray casting mode.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating whether an input value is a supported ndarray casting mode
*
* @example
* var bool = isCastingMode( 'none' );
* // returns true
*
* bool = isCastingMode( 'equiv' );
* // returns true
*
* bool = isCastingMode( 'safe' );
* // returns true
*
* bool = isCastingMode( 'same-kind' );
* // returns true
*
* bool = isCastingMode( 'unsafe' );
* // returns true
*
* bool = isCastingMode( 'foo' );
* // returns false
*/

/**
* Tests whether an input value is a supported ndarray data type.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating whether an input value is a supported ndarray data type
*
* @example
* var bool = isDataType( 'binary' );
* // returns true
*
* bool = isDataType( 'float32' );
* // returns true
*
* bool = isDataType( 'float64' );
* // returns true
*
* bool = isDataType( 'generic' );
* // returns true
*
* bool = isDataType( 'int16' );
* // returns true
*
* bool = isDataType( 'int32' );
* // returns true
*
* bool = isDataType( 'int8' );
* // returns true
*
* bool = isDataType( 'uint16' );
* // returns true
*
* bool = isDataType( 'uint32' );
* // returns true
*
* bool = isDataType( 'uint8' );
* // returns true
*
* bool = isDataType( 'uint8c' );
* // returns true
*
* bool = isDataType( 'foo' );
* // returns false
*/

/**
* Tests whether an input value is a supported ndarray index mode.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating whether an input value is a supported ndarray index mode
*
* @example
* var bool = isIndexMode( 'wrap' );
* // returns true
*
* bool = isIndexMode( 'clamp' );
* // returns true
*
* bool = isIndexMode( 'throw' );
* // returns true
*
* bool = isIndexMode( 'foo' );
* // returns false
*/

/**
* Tests whether an input value is an ndarray order.
*
* @param {*} v - value to test
* @returns {boolean} boolean indicating whether an input value is an ndarray order
*
* @example
* var bool = isOrder( 'row-major' );
* // returns true
*
* bool = isOrder( 'column-major' );
* // returns true
*
* bool = isOrder( 'foo' );
* // returns false
*/

/**
* Tokenize a string.
*
* @module @stdlib/nlp/tokenize
*
* @example
* var tokenize = require( '@stdlib/nlp/tokenize' );
*
* var str = 'Hello Mrs. Maple, could you call me back?';
* var out = tokenize( str );
* // returns [ 'Hello', 'Mrs.', 'Maple', ',', 'could', 'you', 'call', 'me', 'back', '?' ]
*
* str = 'Hello World!';
* out = tokenize( str );
* // returns [ 'Hello', 'World', '!' ]
*/

/**
* Tokenize a string.
*
* @param {string} str - input string
* @param {boolean} [keepWhitespace=false] - boolean indicating whether whitespace characters should be returned as part of the token array
* @throws {TypeError} first argument must be a string primitive
* @throws {TypeError} second argument must be a boolean primitive
* @returns {Array} array of tokens
*
* @example
* var str = 'Hello World!';
* var out = tokenize( str );
* // returns [ 'Hello', 'World', '!' ]
*
* @example
* var str = '';
* var out = tokenize( str );
* // returns []
*
* @example
* var str = 'Hello Mrs. Maple, could you call me back?';
* var out = tokenize( str );
* // returns [ 'Hello', 'Mrs.', 'Maple', ',', 'could', 'you', 'call', 'me', 'back', '?' ]
*/

/**
* Tokenizes a substring.
*
* @private
* @param {string} substr - input string
* @returns {Array} token array
*
* @example
* var str = '(never)';
* var out = tokenizeSubstring( str );
* // returns [ '(', 'never', ')' ]
*/

/**
* Uncapitalize the first character of a string.
*
* @module @stdlib/string/uncapitalize
*
* @example
* var uncapitalize = require( '@stdlib/string/uncapitalize' );
*
* var out = uncapitalize( 'Last man standing' );
* // returns 'last man standing'
*
* out = uncapitalize( 'Hidden Treasures' );
* // returns 'hidden Treasures';
*/

/**
* Uncapitalizes the first character of a string.
*
* @param {string} str - input string
* @throws {TypeError} must provide a string primitive
* @returns {string} input string with first character converted to lowercase
*
* @example
* var out = uncapitalize( 'Last man standing' );
* // returns 'last man standing'
*
* @example
* var out = uncapitalize( 'Presidential election' );
* // returns 'presidential election'
*
* @example
* var out = uncapitalize( 'JavaScript' );
* // returns 'javaScript'
*
* @example
* var out = uncapitalize( 'Hidden Treasures' );
* // returns 'hidden Treasures'
*/

/**
* Validates function options.
*
* @private
* @param {Object} opts - destination for function options
* @param {Options} options - function options
* @param {NonNegativeInteger} [options.depth] - depth to flatten
* @param {boolean} [options.copy] - boolean indicating whether to deep copy array elements
* @returns {(Error|null)} error or null
*
* @example
* var opts = {};
* var options = {
*     'depth': 10,
*     'copy': false
* };
* var err = validate( opts, options );
* if ( err ) {
*     throw err;
* }
*/

/**
* Validates function options.
*
* @private
* @param {Object} opts - destination object
* @param {Options} options - function options
* @param {boolean} [options.codegen] - boolean indicating whether to use code generation
* @param {string} [options.mode] - specifies how to handle indices which exceed array dimensions
* @param {string} [options.submode] - specifies how to handle subscripts which exceed array dimensions
* @returns {(Error|null)} null or an error object
*
* @example
* var opts = {};
* var options = {
*     'mode': 'clamp',
*     'submode': [ 'throw', 'wrap', 'clamp' ],
*     'codegen': false
* };
* var err = validate( opts, options );
* if ( err ) {
*     throw err;
* }
*/

/**
* Wrap an index on the interval `[0,max]`.
*
* @module @stdlib/ndarray/base/wrap-index
*
* @example
* var wrapIndex = require( '@stdlib/ndarray/base/wrap-index' );
*
* var idx = wrapIndex( -1, 10 );
* // returns 10
*
* idx = wrapIndex( 14, 10 );
* // returns 3
*
* idx = wrapIndex( 6, 10 );
* // returns 6
*/

/**
* Wraps an index on the interval `[0,max]`.
*
* @param {integer} idx - index
* @param {NonNegativeInteger} max - maximum index
* @returns {NonNegativeInteger} index
*
* @example
* var idx = wrapIndex( -1, 10 );
* // returns 10
*
* idx = wrapIndex( 13, 10 );
* // returns 2
*
* idx = wrapIndex( 6, 10 );
* // returns 6
*/

/**
* ndarray data buffer constructors.
*
* @module @stdlib/ndarray/base/buffer-ctors
*
* @example
* var ctors = require( '@stdlib/ndarray/base/buffer-ctors' );
*
* var ctor = ctors( 'float64' );
* // returns <Function>
*
* ctor = ctors( 'int' );
* // returns null
*/

/************************************************************************/

/******/

/***/

/*eslint-disable no-self-compare*/

/*eslint-enable no-self-compare*/

/*jshint -W030 */

//  * end > -1 indicates this is not a trailing text node

//  * leading node is when level is -1 and list has length 0

// "Casting" to the same data type is always allowed, regardless of the casting mode...

// --- Welcome to debugging React ---

// ... subsequent chunks get checked to see if they overlap...

// 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'

// Account for augmented dimensions (note: expanding the strides array to account for prepended singleton dimensions does **not** affect the index offset):

// Add a source directive for debugging:

// Add the value argument...

// Adjust the array shape to satisfy the minimum number of dimensions...

// After these have been cleaned up, we'll let them throw.

// Allow the findChunks to be overridden in findAll,

// Anything goes for "unsafe" casting...

// Array shape:

// Avoid spamming the console because they are often not actionable except for lib authors

// Before Symbol spec.

// Buffer offset:

// Build an object containing all ndarray properties needed to revive a serialized ndarray...

// By explicitly using `prop-types` you are opting into new production behavior.

// Cache references to the parent constructor and parent constructor methods:

// Call the parent constructor:

// Case: row-major

// Cast data to generic array...

// Check if module is in cache

// Check if the string starts with a forward slash...

// Check that all array element dimensions are consistent:

// Close the IIFE:

// Close the function call:

// Close the function:

// Closing braces...

// Code generation. Start with function definition...

// Code generation. Start with the function definition...

// Code generation. Start with the function definition:

// Compute percentages...

// Compute the number of bytes...

// Compute the number of elements...

// Copy `shape` and `strides` to prevent external mutation:

// Create a lower-level base constructor:

// Create a new module (and put it into the cache)

// Create a prototype which inherits from the parent prototype:

// Create the code which accesses the nested array values and pushes them onto the flattened array.

// Create the function body...

// Create the function in the current scope to allow access to required modules:

// Create the function in the global scope:

// Create the nested for loops...

// Create the variables...

// Data buffer parameter...

// Detect buggy property enumeration order in older V8 versions.

// Determine if the array can be stored contiguously:

// Determine the minimum and maximum linear indices which are accessible by the array view:

// Don't attach arbitrary props to DOM elements; this triggers React DEV warnings (https://fb.me/react-unknown-prop)

// EXPORTS //

// Eagerly determine array dimensions:

// Empty...

// Ensure that each array element is an array of the same size:

// Ensure that the array is compatible with a single memory segment:

// Equivalent of `typeof` but with special handling for array and regexp.

// Execute the module function

// FUNCTIONS //

// First chunk just goes straight in the array...

// First three values...

// Flag the module as loaded

// Flip the signs of negative strides:

// For each collection element, determine if we've seen the element before. If not, cache a reference which points to its location in the output array; otherwise, update the running count.

// For example, "undefined" or "of type array"

// Function to invoke to create an ndarray:

// Get the size of the current dimension:

// HTML DOM and SVG DOM may have different support levels,

// If `check()` returns a value less than `ndims`, trim off the inconsistent dimensions:

// If an array does not contain any elements, then no data to store, and, if the array is unordered, adjacent array elements are not guaranteed to be stored next to each other.

// If not provided a data buffer, create it; otherwise, see if we need to cast a provided data buffer to another data type or perform a copy...

// If not provided a shape, infer from a provided data source...

// If the "html" passed isn't actually html, add it as a text node.

// If the above failed, fall back to a more robust (and significantly slower) means for resolving underlying data types:

// If the array element is not an array or is not the same size, we have found an inconsistent dimension:

// If the constructor has not already been created, create it; otherwise, return a memoized constructor...

// If the indices are "inbounds", then the buffer length is compatible:

// If the ndarray can be considered both "row-major" and "column-major", then use the default order; otherwise, use the ndarray's stated layout order...

// If the previous statement did not throw an error, we can cache the constructor...

// If the user indicated that "any" order suffices (meaning the user does not care about ndarray order), then we use the default order, unless the input ndarray is either unequivocally "row-major" or "column-major" or configured as such....

// If we didn't find any constructors, this could be due to 1) we have yet to create the constructor or 2) we have been provided invalid options. Either way, let's attempt to create an ndarray constructor...

// If we have yet to determine array strides, we assume that we can compute the strides, along with the index offset, for a **contiguous** data source based solely on the array shape and specified memory layout order...

// If we searched the string to no avail or if the first letter is not `/`, assume that the string is not of the form `/[...]/[guimy]`:

// Important!

// In "safe" casting mode, only casts which preserve values are allowed...

// Infer the array "order" from the stride array (this is supplementary to the `order` parameter):

// Inherit from the parent constructor:

// Initialize the shape/dimensions array:

// Initialize token array:

// It may be the case that prevChunk completely surrounds nextChunk, so take the

// Iterator will provide entry [k,v] tuples rather than values.

// Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

// Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

// Last three values...

// Lazily generate table...

// Load entry module and return exports

// MAIN //

// METHODS //

// MODULES //

// Make `instanceof Error` still work for returned errors.

// Mapping from data types to underlying buffer constructors...

// Mapping from ndarray data buffer constructors to data types...

// Native Symbol.

// New behavior only for users of `prop-types` package

// No casts between different data types are allowed in "none" or "equiv" casting modes...

// Note that, since the stride is negative, this operation increments, not decrements, the offset...

// Note: order should match `ctors` order

// Note: we assume that an option value can be uniquely serialized to a `string` via `JSON.stringify()`...

// Note: we assume that an option value can be uniquely serialized to a `string` via `toString()`...

// Note: we ignore whether `options` has a `buffer` property

// Note: we use an array to avoid unordered key look-up

// Old behavior for people using React.PropTypes

// Only escape the characters between the `/`:

// Only monitor this failure once because there tends to be a lot of the

// Only pass through the highlightIndex attribute for custom components.

// Order:

// Prevent browsers like Firefox from getting stuck in an infinite loop

// Prop type validation may throw. In case they do, we don't want to

// Propagate the number of consistent dimensions up the recursion chain...

// Reassemble:

// Recursively examine nested elements:

// Return the exports of the module

// Return the instance:

// Return the ndarray instance:

// Returns a string that is postfixed to a warning about an invalid type.

// Returns class name of the object, if any.

// SameValue algorithm

// See `createPrimitiveTypeChecker`.

// See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/

// Set private properties...

// Set the constructor to refer to the child constructor:

// Set the value:

// Set up cache to hold tokens for substring matches:

// Some versions of I.E. have different rules for clearTimeout vs setTimeout

// Split on whitespace:

// Stride array...

// TODO: Restrict eventKey to string in v5?

// TODO: replace with `stdlib` pkg

// TODO: reserved for future use

// TODO: validate that minimum number of dimensions does not exceed the maximum number of possible dimensions (in theory, infinite; in practice, determined by max array length; see https://github.com/stdlib-js/stdlib/blob/ac350059877c036640775d6b30d0e98e840d07cf/lib/node_modules/%40stdlib/ndarray/ctor/lib/main.js#L57)

// The approach which follows is to resolve a view index to its subscripts and then plug the subscripts into the standard formula for computing the linear index in the underlying data buffer...

// The module cache

// The require function

// This error was thrown as a convenience so that you can use this stack

// This handles more types than `getPropType`. Only used for error messages.

// This is intentionally an invariant that gets caught. It's the same

// Trivial case where we have all negative strides...

// Trivial case where we have all positive strides...

// Use a heuristic to avoid memoization of highly-specialized ndarray constructors, thus effectively introducing "fast" and "slow" ndarray construction paths...

// VARIABLES //

// Validate some options before others...

// Validate the remaining options...

// WARNING: in C, this is not thread safe

// WARNING: in C, this would not be thread safe

// We do not return zero-length matches

// We don't expect any of the above to throw, but better to be safe.

// We need to check all keys in case some are required but missing from

// We need to de-construct the string...

// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally

// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally

// __webpack_public_path__

// `d` is one more than the index of the last consistent dimension and thus equal to the number of consistent dimensions:

// a child to the current node.

// at `j` is the size of the first non-prepended dimension

// behavior as without this statement except with a better message.

// but for backwards compatibility we export as the old name

// cached from whatever global is present so that test runners that stub it

// calculate correct end of the content slice in case there's

// column-major

// common logic for pushing a child node onto a list

// don't add whitespace-only text nodes if they would be trailing text nodes

// don't break things.  But we need to wrap it in a try catch in case it is

// empty string to avoid regexp issues

// eslint-disable-line max-len

// eslint-disable-line no-buffer-constructor

// eslint-disable-line no-eval

// eslint-disable-line no-new-func

// eslint-disable-line no-new-wrappers

// eslint-disable-line no-underscore-dangle

// eslint-disable-line no-unused-vars

// eslint-disable-line no-useless-escape

// eslint-disable-line stdlib/no-redeclare

// expose the module cache

// expose the modules object (__webpack_modules__)

// fail the render phase where it didn't fail before. So we log it.

// function because try/catches deoptimize in certain engines.

// http://fb.me/prop-types-in-prod

// https://bugs.chromium.org/p/v8/issues/detail?id=3056

// https://bugs.chromium.org/p/v8/issues/detail?id=4118

// https://www.w3.org/TR/html4/struct/text.html#h-9.1

// if a node is nothing but whitespace, collapse it as the spec states:

// if clearTimeout wasn't available but was latter defined

// if setTimeout wasn't available but was latter defined

// if we're at root, push new base node

// if we're at the root, push a base text node. otherwise add as

// largest of the end indeces.

// no tag after the text node.

// non-generic

// or if they would be leading whitespace-only text nodes:

// props.

// row-major

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.

// same error.

// shim for using process in browser

// slight optimization to avoid modulo arithmetic when max+1 < idx <= 2*(max+1)

// slight optimization to avoid modulo arithmetic when |idx| <= max+1

// so we need to check on context instead of a document root element.

// to find the callsite that caused this warning to fire.

// trailing text node

// v8 likes predictible objects

// we don't care about invariant's own frame

// weak test

// webpackBootstrap

// when when somebody has screwed with setTimeout but no I.E. maddness

// wrapped in strict mode code which doesn't define any globals.  It's inside a

//# sourceMappingURL=index.js.map

//# sourceMappingURL=main.js.map

//normal enviroments in sane situations
