/* harmony default export */

/* harmony import */

/*#__PURE__*/

/**
	* Constant function.
	*
	* @private
	* @returns {*} constant value
	*/

/**
	* Returns a pseudorandom number drawn from a discrete uniform distribution with minimum support `a` and maximum support `b`.
	*
	* @private
	* @param {integer} a - minimum support
	* @param {integer} b - maximum support
	* @returns {integer} pseudorandom number
	*
	* @example
	* var v = discreteUniform2( 1, 10 );
	* // returns <number>
	*
	* @example
	* var v = discreteUniform2( 1, 0 );
	* // returns NaN
	*/

/**
	* Returns a pseudorandom number drawn from a discrete uniform distribution with minimum support `a` and maximum support `b`.
	*
	* @private
	* @returns {integer} pseudorandom number
	*
	* @example
	* var v = discreteUniform1();
	* // returns <number>
	*/

/**
	* Returns the PRNG seed length.
	*
	* @private
	* @returns {PositiveInteger} seed length
	*/

/**
	* Returns the PRNG seed.
	*
	* @private
	* @returns {PRNGSeedMT19937} seed
	*/

/**
	* Returns the PRNG state length.
	*
	* @private
	* @returns {PositiveInteger} state length
	*/

/**
	* Returns the PRNG state size (in bytes).
	*
	* @private
	* @returns {PositiveInteger} state size (in bytes)
	*/

/**
	* Returns the current pseudorandom number generator state.
	*
	* @private
	* @returns {PRNGStateMT19937} current state
	*/

/**
	* Serializes the pseudorandom number generator as a JSON object.
	*
	* ## Notes
	*
	* -   `JSON.stringify()` implicitly calls this method when stringifying a PRNG.
	*
	* @private
	* @returns {Object} JSON representation
	*/

/**
	* Sets the pseudorandom number generator state.
	*
	* @private
	* @param {PRNGStateMT19937} s - generator state
	* @throws {Error} must provide a valid state
	*/

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*
* ## Notice
*
* The original C++ code and copyright notice are from the [Boost library]{http://www.boost.org/doc/libs/1_65_1/doc/html/boost/random/uniform_int_distribution.html}. The implementation has been modified for JavaScript.
*
* ```text
* (C) Copyright John Maddock 2006.
* (C) Copyright Steven Watanabe 2011.
*
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
* ```
*/

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* A dynamic background component that cycles through a list of texts  at a specified interval.
*
* @property {Array} list - list of texts to be displayed
* @property {boolean} loop - indicates whether the process shall be displayed infinitely
* @property {string} direction - the direction of the text flow (either `left`, `right`, `up`, `down`, `tracking`, `focus`, or `swirl`)
* @property {number} still - the time the text remains still (in seconds)
* @property {number} interval - the interval between the calls (in seconds)
* @property {number} inTime - time of the entrance effect (in seconds)
* @property {number} outTime - time of the exit effect (in seconds)
* @property {string} className - class name
* @property {Object} style - CSS styles of the text
*/

/**
* Create a constant function.
*
* @module @stdlib/utils/constant-function
*
* @example
* var constantFunction = require( '@stdlib/utils/constant-function' );
*
* var fcn = constantFunction( 3.14 );
*
* var v = fcn();
* // returns 3.14
*
* v = fcn();
* // returns 3.14
*
* v = fcn();
* // returns 3.14
*/

/**
* Creates a function which always returns the same value.
*
* @param {*} [value] - value to always return
* @returns {Function} constant function
*
* @example
* var fcn = wrap( 3.14 );
*
* var v = fcn();
* // returns 3.14
*
* v = fcn();
* // returns 3.14
*
* v = fcn();
* // returns 3.14
*/

/**
* Discrete uniform distribution pseudorandom numbers.
*
* @module @stdlib/random/base/discrete-uniform
*
* @example
* var discreteUniform = require( '@stdlib/random/base/discrete-uniform' );
*
* var v = discreteUniform( 1, 10 );
* // returns <number>
*
* @example
* var factory = require( '@stdlib/random/base/discrete-uniform' ).factory;
* var discreteUniform = factory( -5, 5, {
*     'seed': 297
* });
*
* var v = discreteUniform();
* // returns <number>
*
* @example
* var factory = require( '@stdlib/random/base/discrete-uniform' ).factory;
* var discreteUniform = factory({
*     'seed': 297
* });
*
* var v = discreteUniform( -5, 5 );
* // returns <number>
*/

/**
* Returns a pseudorandom number drawn from a discrete uniform distribution with minimum support `a` and maximum support `b`.
*
* ## Method
*
* -   Let \\( R \\) be a pseudorandom generator (PRNG) which yields integers on the interval \\( \[ A, B ] \\).
*
* -   If \\( a = b \\), then \\( rv = a \\).
*
* -   Let \\( r1 = b - a \\) and \\( r2 = B - A \\). If \\( r2 = r1 \\) (likely a rare occurrence), then
*
*     ```tex
*     rv = ( R() - B ) + a
*     ```
*
*     where, for real integer types, operation order is important in order to avoid overflow.
*
* -   If \\( r2 < r1 \\), use rejection sampling to map random variates from \\( R \\) to a larger domain (e.g., \\( {0,1,2,3} \rightarrow {0,1,2,3,4} \\)). For real integer types (and floating-point integer values), we must take extra care to avoid overflow. During sampling, the following conditions will hold:
*
*     -   First, consider the post-condition: \\( \textrm{result} \leq r2 \\), thus avoiding overflow.
*
*     -   Begin with definition of \\( \textrm{limit} \\)
*
*         ```tex
*         \textrm{limit} = \lfloor{\frac{r2+1}{r1+1}\rfloor
*         ```
*
*         thus,
*
*         ```tex
*         \textrm{limit}\ \cdot (r1+1) \leq r2+1
*         ```
*
*     -   Let \\( m \\) be a random factor where the loop condition is defined as
*
*         ```tex
*         m \leq \textrm{limit}
*         ```
*
*     -   Let \\( \textrm{result} \\) be the generator output, which is expressed base \\( r2+1 \\) and obeys the loop invariant \\( \textrm{result} < m \\).
*
*     -   Let \\( rv \\) be a realization of the PRNG. Then,
*
*         ```tex
*         rv-A \leq r1
*         ```
*
*         and, by the loop condition, \\( m \leq \textrm{limit} \\).
*
*     -   Therefore,
*
*         ```tex
*         m \cdot (rv - A + 1) \leq r2+1
*         ```
*
*     -   Rearranging terms,
*
*         ```tex
*         m + m \cdot (rv - A) \leq r2+1
*         ```
*
*     -   Since \\( \textrm{result} < m \\),
*
*         ```tex
*         \textrm{result} + m \cdot (rv - A) < r2+1
*         ```
*
*     -   Next, consider the post-condition: \\( \textrm{result} < m \cdot (r2+1) \\).
*
*     -   Since \\( \textrm{result} < m \\) and \\( rv - A \leq r1 \\),
*
*         ```tex
*         \textrm{result} + m \cdot (rv - A) < m + m \cdot (rv - A)
*         ```
*
*     -   Therefore,
*
*         ```tex
*         \textrm{result} + m \cdot (rv - A) < m + m \cdot r1
*         ```
*
*     -   Therefore,
*
*         ```tex
*         \textrm{result} + m \cdot (rv - A) < m \cdot (r1+1)
*         ```
*
*     -   Next, consider the post-condition: \\( m \leq r2 \\).
*
*     -   According to the definition of \\( \textrm{limit} \\) and the loop condition \\( m \leq \textrm{limit} \\),
*
*         ```tex
*         m \cdot (r1+1) \leq r2+1
*         ```
*
*     -   If \\( r2 \\) is **not** an integer power of the generator range \\( r1 \\), i.e.,
*
*         ```tex
*         m \cdot (r1+1) \neq r2+1
*         ```
*
*         then
*
*         ```tex
*         m \cdot (r1+1) < r2+1
*         ```
*
*     -   Thus, \\( \textrm{result} < m \\).
*
*     -   Next, consider the post-condition: \\( r2/m < r1+1 \\).
*
*     -   To show this is true, let us try to prove its opposite. Given the loop condition \\( m > \textrm{limit} \\), assume
*
*         ```tex
*         r2/m > r1+1
*         ```
*
*     -   Accordingly,
*
*         ```tex
*         r2 \geq m \cdot (r1+1)
*         ```
*
*     -   Hence,
*
*         ```tex
*         r2+1 > m \cdot (r1+1)
*         ```
*
*     -   Using the loop condition,
*
*         ```tex
*         r2+1 > (\textrm{limit}+1) \cdot (r1+1)
*         ```
*
*     -   Rearranging terms,
*
*         ```tex
*         \frac{r2+1}{r1+1} > \textrm{limit} + 1
*         ```
*
*     -   Hence,
*
*         ```tex
*         \textrm{limit} < \lfloor{\frac{r2+1}{r1+1}} \rfloor
*         ```
*
*     -   But the definition of \\( \textrm{limit} \\) is
*
*         ```tex
*         \textrm{limit} = \lfloor{\frac{r2+1}{r1+1}}
*         ```
*
*     -   Thus, our assumption cannot be true, providing the post-condition by reductio ad absurdum.
*
*     -   Next, consider the post-condition
*
*         ```tex
*         r2 \leq \frac{r2}{m} \cdot m + (m - 1)
*         ```
*
*     -   Recall the identity
*
*         ```tex
*         r2 = \frac{r2}{m} \cdot m + r2 \mod m
*         ```
*
*     -   By the definition of the modulus
*
*         ```tex
*         r2 \mod m < m
*         ```
*
*     -   Therefore,
*
*         ```tex
*         r2 < \frac{r2}{m} \cdot m + m
*         ```
*
*     -   Hence,
*
*         ```tex
*         r2 \leq \frac{r2}{m} \cdot m + (m - 1)
*         ```
*
*     At this point, the maximum value \\( \textrm{result} \\) is \\( m-1 \\). Hence, we can generate numbers that can be at least as large as \\( r2 \\), but we must be careful to avoid overflow during addition and in the sampling rejection. Anything which overflows is larger than \\( r2 \\) and can thus be rejected.
*
* -   If \\( r1 > r2 \\), use rejection sampling to map random variates from \\( R \\) to a smaller domain (e.g., \\( {0,1,2,3,4} \rightarrow {0,1,2,3} \\)) by defining "buckets" in which multiple random variates in \\( R \\) map to a single random variate in the smaller domain. We are safe in adding 1 to \\( r2 \\); however, we need to be careful to not cause overflow when adding 1 to \\( r1 \\).
*
* @name discreteUniform
* @type {PRNG}
* @param {integer} a - minimum support
* @param {integer} b - maximum support
* @returns {integer} pseudorandom number
*
* @example
* var v = discreteUniform( 1, 10 );
* // returns <number>
*/

/**
* Returns a pseudorandom number drawn from a discrete uniform distribution with minimum support `a` and maximum support `b`.
*
* @private
* @param {PRNG} rand - pseudorandom number generator which outputs integer values
* @param {integer} a - minimum support
* @param {integer} b - maximum support
* @returns {integer} pseudorandom number
*/

/**
* Returns a pseudorandom number generator for generating random numbers draw from a discrete uniform distribution.
*
* @param {integer} [a] - minimum support
* @param {integer} [b] - maximum support
* @param {Options} [options] - function options
* @param {PRNG} [options.prng] - pseudorandom number generator which generates uniformly distributed pseudorandom integers
* @param {PRNGSeedMT19937} [options.seed] - pseudorandom number generator seed
* @param {PRNGStateMT19937} [options.state] - pseudorandom number generator state
* @param {boolean} [options.copy=true] - boolean indicating whether to copy a provided pseudorandom number generator state
* @throws {TypeError} `a` must be an integer
* @throws {TypeError} `b` must be an integer
* @throws {RangeError} `a` must be less than `b`
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {TypeError} provided PRNG must have a valid `MIN` property
* @throws {TypeError} provided PRNG must have a valid `MAX` property
* @throws {Error} must provide a valid state
* @returns {PRNG} pseudorandom number generator
*
* @example
* var discreteUniform = factory( 1, 10 );
* var v = discreteUniform();
* // returns <number>
*
* @example
* var discreteUniform = factory( -30, -1, {
*     'seed': 297
* });
* var v = discreteUniform();
* // returns <number>
*/

/**
* Validates values provided for minimum and maximum support.
*
* @private
* @param {integer} a - minimum support
* @param {integer} b - maximum support
* @returns {(Error|null)} error or null
*
* @example
* var err = validate( 1, 20 );
* if ( err ) {
*     throw err;
* }
*/

/***/

// Avoid overflow...

// Case: RANGE > range

// EXPORTS //

// Equivalent to (mult * (RANGE+1)) == range+1, but avoids overflow...

// Exports

// For every power of `(RANGE+1)`, we determine a random factor:

// If we are provided an "external" PRNG, we don't support getting or setting PRNG state, as we'd need to check for compatible state value types, etc, entailing considerable complexity.

// Loop invariants: result < mult && mult <= range

// MAIN //

// MODULES //

// Module

// Note: see first and second post-conditions.

// Note: see third post-condition.

// PROPERTIES //

// The destination range is an integer power of the generator's range...

// We consider `result` as expressed base `(RANGE+1)`:

// When determining the bucket size, avoid overflow...

// e.g., 5%(2+1) == 2

// in JavaScript, we only explicitly have doubles

// range/mult < RANGE+1 (no endless loop)
